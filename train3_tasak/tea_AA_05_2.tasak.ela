kirjak	tea_AA_05_2.tasak.ela	A &amp; A <arv>. aasta neljandas numbris esitasime ülevaate agiilmetoodikatest tarkvaraarenduses . Teatavaks probleemiks oli ingliskeelsele sõnale “ agile ” vaste leidmine . Infotehnoloogia keeleguru Vello Hanson nentis , et “ paind(metoodikad)<arv>” ei saa kasutada , kuna sellel mõistel juba on eestikeelne konkreetne tähendus . Ka muud otsetõlked tundusid kohmakad . Nii soovitaski Vello Hanson võtta laen ladina keelest ja kasutada eesti keeles “ agiilmetoodikad ” . Tartlased , kes üldiselt õigesti võitlevad eesti keele võõrsõnadega risustamise vastu , võtsid hiljem “ agile ” vasteks “ väle ” , seega “ väledad metoodikad ” . Miks mitte , kuid “ agile ” leiab inglise keeles märksa laiemat kasutamist , näiteks agile technology /manufactoring : Taiichi Ohno poolt loodud Toyota Production System ( Kanban Approach ) <arv> . Kas nimetada Kanbani “ väledaks tehnoloogiaks/tootmiseks ” ? Eks tartlastest keeleeksperdid otsusta . Selle kirjutise teemat “ Agile project management ” ma igatahes “ väledaks projektijuhtimiseks ” tõlkida ei taha/ei suuda . Toome igaks juhuks veel agiilsuse määratluse James Highsmithilt : Agility is the ability to both create and respond to change in order to profit in a turbulent business environment . Agility is the ability to balance flexibility and stability <arv> Jääb mulje , et “ agile ” vastena “ väle ” kasutamine on agiilsuse pinnapealse käsitlemise tulemus . Segi on aetud põhjus ja tagajärg : muudatustele reageeriva metoodika kasutamise üheks tulemuseks ( mitte ainsaks ! ) on väle tarkvara arendusprotsess . Paneme tähele , et metoodika realisatsiooni = konkreetne arendusprotsess puhul on “ väle ” kasutamine mõistetav , metoodika ise kui arendusprotsesside karkass väle olla ei saa . Läheme nüüd teema juurde . Klassikaline juhtimisteooria eeldab et : hierarhilised organisatsiooni struktuurid on vahendiks korra loomisel ; mida enam kontrolli , seda enam korda ; töötajad on “ vahetatavad osad ” organisatsiooni “ masinas ” ; probleemid lahendatakse “ jaga ja valitse ” printsiibil ; projekti täitmise kulg ja riskid on piisavalt prognoositavad ja seega hallatavad põhjaliku eelneva plaanimisega . Nendest eeldustest lähtudes ongi loodud klassikaline projektijuhtimise teooria . Tänapäeva kiiresti muutuvas ärikeskkonnas aga need “ loomulikud ” eeldused ei kehti ja seetõttu pole nende printsiipide alusel loodud klassikalise projektijuhtimise metoodikad rakendatavad . Uue projektijuhtimise metoodika väljatöötamisega on tegelenud mitmed uurijad , siinkohal piirdume paari viitega<arv>. Keeruliste adaptiivsete süsteemide ( complex adaptivesystems ( CAS ) ) teooriat on edukalt rakendatud mitmes valdkonnas ( nt majandus ) , huvipakkuv on ka sellele teooriale tuginev projektijuhtimise käsitlus . Keerulistes adaptiivsetes süsteemides tegutsevatel “ agentidel ” on vaid lihtsad lokaalsed strateegiad ( tegutsemise reeglid ) , kuid nende agentide kollektiivset käitumist iseloomustab kord , iseorganiseerumine ja kollektiivne intelligents , mis on suurem “ agentide ” intelligentside summast ( sünergia ) . Keeruliste adaptiivsete süsteemide teooria rakendamisel projektijuhtimise valdkonnas jõuame olulise printsiibini : projektijuht peab olema adaptiivne liider , mitte ainult projekti kavandaja ja täitmise kontrollija ( projekti administraator ) . Projektimeeskonna liikmed , “ agendid ” , tegutsevad lihtsate reeglite alusel , projektijuhi ülesanne on võimaldada meeskonnal ise-organiseeruda , tagada meeskonna kollektiivse tegutsemise sünergia . Projektijuht ise ju “ tööd ei tee ” ( traditsiooniline nali : projektijuhi ülesandeks o n käia võileibu toomas ja siis kaduda , et tööd mitte segada ) , oma olemasolu õigustab ta vaid väärtuse lisamisega projektimeeskonna töösse . Agiilsed projektijuhid aitavad tiimil balansseerida kaose piiril : tiimil peab olema struktuur - kuid mitte liiga palju ; on vaja projektdokumentatsiooni - kuid mitte liiga palju ; süsteemi arhitektuur on oluline - kuid seda pole vaja liiga detailset jne. Niisuguste tasakaalupunktide tunnetamine , nende leidmine ongi agiilse projektijuhtimise aluseks . Projektijuhi kui liidri esmaseks ülesandeks on näidata suunda , anda juhiseid , mitte käskida ja kontrollida . Lõpetuseks : loodame , et äratasime lugejas huvi , järgmises A &amp; A numbris vaatleme lähemalt agiilse projektijuhtimise praktikaid . <arv> Gunnar Piho , viidates prof. Leo Võhandule , kasutab siiski “ paindmetoodikad ” . Vt . G. Piho , Eesti tarkvaraarendajate kogemused arendusmetoodika kasutamisel , A &amp; A Nr . <arv> , <arv>. <arv> Kennedy , Michael N. Product Development for the Lean Enterprise : Why Toyota's System is Four Times More Productive and How You Can Implement It . Richmond , VA : The Oaklea Press , <arv>. <arv> Highsmith , James A. , III . Adaptive Software Development : A Collaborative Approach to Managing Complex Systems . New York : Dorset House Publishing , <arv>. <arv> Cockburn , Alistair . Agile Software Development . Boston : Addison-Wesley , <arv>. Quote on p. <arv> © <arv> Pearson Education , Inc. DeMarco , Tom , and Tim Lister . Waltzing with Bears : Managing Risk on Software Projects . New York : Dorset House , <arv>. Howell , Greg , and Lauri Koskela . “ Reforming Project Management : The Role of Planning , Execution , and Controlling ” . In David Chua and Glenn Ballard ( eds . ) , Proceedings of the <arv>th International Group for Lean Construction Conference , <arv>-<arv>. Singapore : National University of Singapore , <arv>. Arvo Toomsalu , TTÜ arvutitehnika instituut Microchip Technology Inc. PIC-mikrokontrollersarjade originaalsed arhitektuursed lahendused ja kõrged tehnilised näitajad on taganud firmale juhtiva positsiooni <arv>-bitiste mikrokontrollerkiipide turul . Alates <arv>. aastast , kui alustati PIC-sarja mikrokontrollerite tööstuslikku tootmist , on valminud üle kolme miljardi erineva kontrollerkiibi . Firma tootmisstrateegia näeb ette , et pidevalt arendatakse edasi ja täiustatakse nii olemasolevaid mikrokontrollerkiipide sarju kui töötatakse välja ka uusi . Kui seni esindas kõige lihtsamaid PIC-mikrokontrollereid PIC<arv>C<arv>x-sari [ <arv> ] , siis nüüd on firma välja töötanud uue originaalse sarja PIC<arv>F<arv>x . Vastse sarja kõige olulisemateks iseärasusteks on üliväike kontrollerkiip ning mikrokontrolleri suhtlus väliskeskkonnaga üksnes jadakanali vahendusel . PIC<arv>F<arv>x-sarja mikrokontrollerkiibid on praegu kõige väiksemad <arv>-bitised mikrokontrollerlülitused . Võrreldes teiste sama klassi mikrokontrollerkiipidega , näevad nad tõesti välja nagu pisikesed putukad . Nii väikese jälgpinna ja minimaalse sisend-väljundviikude arvuga <arv>-bitist mikrokontrollerit ei valmista ükski teine firma . Nagu ühele “ putukale ” kohane , on PIC <arv>F<arv> ja PIC<arv>F<arv> mikrokontrollerid varustatud kõigest kuue viiguga<arv>. Et kiibi viikude arvu on vähendatud miinimumini , siis on ka mõistetav , miks kontrollerlülituste suhtlus välisilmaga toimub üksnes jadamisi . Mõneti on selline lahendus küllaltki ootamatu . Läbi aegade võis mikrokontrollerite mikroarhitektuuri arendamisel täheldada tendentsi , et püüti igati suurendada portide , eeskätt rööpportide arvu kiipides . Esialgu varustati mikrokontrollerid üldse vaid rööpportidega , alles hiljem hakati neisse vähehaaval lisama jadaporte . Nüüd on siis Microchip jõudnud aga nii kaugele , et mikrokontrolleris puuduvad rööppordid täielikult . Muidugi ei suuda jadamisi toimuv andmeedastus võistelda rööpedastusega , kuid praktikas leidub piisavalt rakendusi , kus mikrokontrolleri jaoks pole primaarne mitte niivõrd ülikiire andmevahetuse tagamine kui hoopiski teised näitajad ( kompaktsus , ökonoomsus , odavus jne ) . Nimelt sellistele rakendustele ongi orienteeritud uus PIC-mikrokontrollerlülituste sari . Vaatamata mitmele arhitektuurilis-struktuursele muudatusele , tuginetakse selleski PIC-sarjas RISC-kontseptsioonile . Tänu RISC-arhitektuuris peituvate võimaluste oskuslikule ärakasutamisele on Microchipil õnnestunud , vaatamata kontrollerlülituste mikroarhitektuuri näivale lihtsusele , saavutada kiipide märkimisväärselt kõrge jõudlus . Järgnevalt vaatlekski lühidalt neid olulisemaid iseärasusi , mis iseloomustavad Microchipi uue PIC<arv>F<arv>x-sarja mikrokontrollereid . PIC<arv>F<arv>X-SARJA MIKROKONTROLLERID PIC<arv>F<arv>x-sarja kuulub esialgu neli erinevate tehniliste näitajatega , kuid ühesuguse arhitektuurse lahendusega , <arv>-bitise sõnapikkusega mikrokontrollerkiipi - PIC<arv>F<arv> , PIC<arv>F<arv> , PIC<arv>F<arv> ja PIC<arv>F<arv> . Põhilised erinevused mikrokontrollerlülituste vahel on nende sisemälude ( andme- ja programmimälude ) infomahutavuses ning analoog-võrdluslülituse olemasolus ( tabel <arv> ) . Tabel <arv> PIC<arv>F<arv>x-sarja mikrokontrollerkiipide põhinäitajaid  Tüüp Programmi mälu Andmemälu S/V-viikude arv <arv>-bitine taimer Võrdlus- lülitus PIC<arv>F<arv> <arv> x <arv> bitti <arv> x <arv> bitti <arv> <arv> PIC<arv>F<arv> <arv> x <arv> bitti <arv> x <arv> bitti <arv> <arv> PIC<arv>F<arv> <arv> x <arv> bitti <arv> x <arv> bitti <arv> <arv> <arv> PIC <arv>F <arv> <arv> x <arv> bitti <arv> x <arv> bitti <arv> <arv> <arv> Kõige lihtsamaid ja väiksemaid mikrokontrollerlülitusi esindavad sarjas kiibid PIC<arv>F<arv> ja PIC<arv>F<arv> . Selles , et tegemist on suisa askeetlike mikrokontrollerlülitustega , on kerge veenduda , kui analüüsida kiipide mikroarhitektuurset lahendust ( joonis <arv> ) . MIKROKONTROLLERITE PIC<arv>F<arv>/<arv> PÕHILISED FUNKTSIONAALSED ÜKSUSED TAKTIGENERAATOR Täisstaatilise CMOS-tehnoloogias valmistatud mikrokontrollerlülituse takteerimine toimub kiibisisese taktigeneraatoriga ( ICLK ) , mis töötab sagedusel <arv> <arv>% MHz . Kiibis moodustab spetsiaalne ajastuslülitus ( TU ) taktigeneraatorist saadud signaalidest signaalijada . See koosneb neljast üksteisega mittekattuvast taktist ( taktitetraadist ) Q<arv> , Q<arv> , Q<arv> ja Q<arv> . Iga selline taktitetraad vastab ühele käsutsüklile ( joonis <arv> ) . Käsutsükli kestus taktsagedusel <arv>MHz on võrdne ühe mikrosekundiga . ARITMEETIKA-LOOGIKASEADE Mikrokontrolleri universaalses <arv>-bitises paralleeltoimelises aritmeetika-loogikaseadmes ( ALU ) tehakse erinevaid aritmeetika- ja loogikaoperatsioone . ALU talitlusel asub üks operandidest alati <arv>-bitises töö- ehk W-registris ( WRG ) , teine võib aga asuda kas registrikogumi registris või olla käsus ette antud kui vahetu operand . Tööregistri W iseärasuseks on see , et register pole adresseeritav . ALU talitlusega on tihedalt seotud ka <arv>-bitine olekusõnaregister ( STATRG ) , kus säilitatakse nii aritmeetiliste operatsioonide täitmisel moodustunud tunnusbitte ( C-Carry , DC-Digit Carry , Z-Zero ) kui ka taimeri , üldotstarbelise sisend-väljundlülituse ja toiteohjega seotud juhtinformatsiooni . TAIMER -LOENDUR Mikrokontroller on varustatud universaalse programselt ohjatava <arv>-bitise taimer-loenduriga ( TIM ) . Taimer-loendur ja valvetaimer ( WDT ) kasutavad ühist programselt juhitavat sageduse eeljagurit ( prescaler ) . Igal ajahetkel saab eeljagurit kasutada siiski vaid ainult üks neist lülitustest . Kuigi eeljaguri talitlust ohjatakse programselt , ei ole selle olek otseselt siiski jälgitav-juhitav . Juhul kui sagedusjagajat kasutab taimer-loendur , siis selle jagamisteguri fikseeritud väärtuseks võivad olla kas <arv> : <arv> , <arv> : <arv> või <arv> : <arv>. Üldjuhul takteeritakse taimer-loendurit sisemiselt taktigeneraatorilt , kuid selle takteerimine võib toimuda ka kiibiväliselt ( läbi viigu GP<arv>/T<arv>CKI ) . Kiibivälisel takteerimisel tuleb arvestada aga sellega , et väliseid (takt)signaale sünkroniseeritakse omakorda mikrokontrolleri sisetaktidega . VALVETAIMER Valvetaimerit ( WDT ) takteeritakse autonoomselt kiibisiseselt , taktigeneraatorist ICLK sõltumatult talitlevast RC-generaatorilt . Valvetaimeri generaator jätkab tööd isegi juhul , kui mingil põhjusel , näiteks siirdumisel suikerežiimi , lakkab taktigeneraatori ICLK talitlus . Valvetaimeri jaoks on fikseeritud taimaut-perioodi kestus , see võrdub <arv> millisekundiga . Kui soovitakse pikemat kontrolli- tsükli perioodi , siis tuleb appi võtta eelnevalt nimetatud sageduse eeljagur . Sageduse eeljaguri kasutamine taimer-loenduri ja valvetaimeri korral on pisut erinev . Kui taimer-loenduri korral täidab lülitus sageduse eeljaguri funktsiooni , siis valvetaimeri puhul on tegemist järeljaguriga ( postscaler ) . Programselt saab sagedusjaguris jagamisteguri väärtust muuta maksimaalselt kuni suhteni <arv> : <arv>. Sel juhul pikeneb taimaut kuni <arv>,<arv> sekundini . Et tegemist on generaatoriga , mida ei stabiliseerita kvartsresonaatoriga , siis avaldab välistemperatuuri kõikumine valvetaimeri talitlustäpsusele küllaltki suurt mõju . Joonisel on kasutatud järgmisi mnemoonilisi tähistusi : PRG MEM - programmimälu ; DAT MEM - andmemälu ; PC - käsuloendur ; ST<arv> , ST<arv> - pinu <arv> ja pinu <arv> ; IR - käsuregister ; MUX - multiplekser ; FSRG - erifunktsioonide register ; ALU - aritmeetika-loogikaseade ; ID &amp; CNT - käskude dekooder ja juhtlülitus ; TU - taktsignaalide ajastuslülitus ; DRT - lähtestustaimer ; POR - lähtestuslülitus ; WDT - valvetaimer ; ICLK - sisemine RC-taktigeneraator ; WRG - W-register ; TIM - taimer-loendur ; STATRG - olekusõnaregister ; GPIO - üldotstarbeline S/V-lülitus ; Program Bus - programmisiin ; Data Bus - andmesiin ; Direct Address - otseaadress ; Indirect Address - kaudaadress . Numbrid siinidel näitavad siini laiust . Sisend-väljundsignaalide ( GP<arv>/CSPDAT , GP<arv>/CSPCLK , GP<arv>/T <arv> CKI/FOSC<arv> , MCLR/Vpp , Vss ja Vdd ) funktsioonid on toodud tabelis <arv>. Rombikesed tähistavad sisend-väljundviike .  Joonis <arv>. Mikrokontrolleri(te) PIC<arv>F<arv>/<arv> plokkskeem MÄLUSÜSTEEM Mikrokontrolleri mälusüsteem on üles ehitatud klassikalise Harvardi arhitektuurse mudeli alusel , milles kasutatakse eraldi programmi- ( PRG MEM ) ja andmemälusid ( DAT RAM ) . Olenevalt mälulülituste infomahutavusest on kontrollerlülituses kas <arv>- või <arv>-bitine käsuloendur ( PC ) . Käsuloendur võimaldab otseselt adresseerida vastavalt kas <arv> või <arv> mäluaadressi . PROGRAMMIMÄLU Olenevalt mikrokontrollerkiibist saab programmimälus ( PRG MEM ) reaalselt kasutada kas <arv> ( PIC<arv>F<arv>/<arv> <arv> ) või <arv> ( PIC<arv>F<arv> <arv> /<arv> ) aadressi , kuigi kontrolleri käsuloendur võimaldab adresseerida vastavalt kas <arv> või <arv> aadressi . Mälusõna pikkuseks programmimälus on <arv> bitti . Osa aadresse ( mälupesi ) programmimälus reserveeritakse teatava kindla informatsiooni tarbeks . Näiteks kiipides PIC<arv>F<arv>/<arv> <arv> säilitatakse aadressil <arv>h lähtestusvektori väärtust ja aadressil <arv>FFh konstandi väärtust , mida kasutatakse kontrollerkiibi taktigeneraatori ohjel . Programmimäluna kasutatakse moodsat kiirkustusega püsimälulülitust . Mälulülituses saab sooritada kuni <arv> <arv> salvestustsüklit , salvestatud informatsioon säilib selles kuni <arv> aastat . ANDMEMÄLU Andmemälu ( DAT MEM ) infomahutavus on võrdlemisi tagasihoidlik . Nagu programmimälude korral , nii sõltub ka andmemälude infomahutavus kontrollerkiibist . Kui PIC<arv>F<arv>/<arv> korral piirdub see kõigest <arv> x <arv> bitiga , siis kiipide PIC<arv>F<arv>/<arv> <arv> puhul on andmemälu infomahutavus veidi suurem ( <arv> x <arv> bitti ) . Struktuurselt on andmemälu korraldatud kahe mälusegmendina , segmentide ohje toimub registrikogumis FSRG säilitatava informatsiooni abil . Funktsionaalselt on andmemälu jaotatud samuti kaheks - erifunktsioonide registriteks ( näiteks kiipide PIC<arv>F<arv>/<arv> korral asuvad need aadressivahemikus <arv>Fh-<arv>h ) ja üldotstarbelisteks registriteks ( asuvad aadressivahemikus <arv>Fh-<arv>h ) . Kõik andmemälu mälupesad ( registrid ) on <arv>-bitised . Mis puutub erifunktsioonide registrikogumisse , siis selle koosseisu kuuluvad näiteks taimerregister , käsuloendur , olekuregister , valikuregister ( selles registris oleva informatsiooni abil juhitakse taimer-loenduri ja valvetaimeri talitlusrežiime ) , sisemise taktigeneraatori juhtimise ( kalibreerimise ) register , sisend-väljundregister , failivaliku register . Selles registris säilitatava informatsiooni abil konfigureeritakse samuti üldotstarbelise S/V-pordi ( GPIO ) viigud vastavalt kas informatsiooni sisestuse või väljastuse režiimi , ning ohjatakse mitmete teiste funktsioonide täitmist . Üldotstarbelised registrid on ette nähtud käskudes esineva andme- ja juhtinformatsiooni säilitamiseks . Pöördused üldotstarbeliste registrite poole võivad toimuda kas otse või kaudselt ( kasutades FSRG-registri abi ) . PINUMÄLU Mikrokontrollerite pinumälu on äärmiselt lihtsa korraldusega . Nimelt moodustavad kahetasemelise pinumälu kaks <arv>-bitist registrit ( ST<arv> ja ST<arv> ) . SISEND-VÄLJUNDSÜSTEEM Erinevalt enamikust teistest praegu kasutatavatest mikrokontrolleritest on PIC<arv>F<arv>x-sarja mikrokontrolleritel äärmiselt omapärane sisend-väljundsüsteemi korraldus . Neis on hüljatud mikrokontrollerite mikroarhitektuuri üks iseloomulikumaid põhimõtteid - arenenud , mitmekesiste võimalustega S/V-süsteemi olemasolu . PIC<arv>F<arv>x-sarja mikrokontrollerite S/V-süsteemi iseloomustab kaks põhitunnust : <arv>. Äärmine minimalism , kontrollereis piirdutakse vaid nelja sisend-väljundviiguga<arv>. <arv>. Andmevahetusel rakendatakse informatsiooni jadaedastust . Kõik sisend-väljundoperatsioonid toimuvad programsel juhtimisel . Pärast mikrokontrollerlülituse lähtestust viiakse kõik S/V-liinid automaatselt olekusse , mis vastab informatsiooni sisestamise režiimile . S/V-operatsioonid toimuvad kahe registri - GPIO ja TRIS abil ( sisuliselt on need registrid GPIO-lülituses kokku ehitatud ) . Vaatamata sellele , et GPIO-register on kiibis <arv>-bitine , kasutatakse sellest vaid nelja nooremat järku ( GP<arv> kuni GP<arv> ) . Kolm registri viikudest ( GP<arv> - GP<arv> ) on kahesuunalised , neid saab programmeerida mikrokontrollerisse vastavalt kas informatsiooni sisestamiseks või väljastamiseks . Viik GP<arv> on ühesuunaline ning kasutatav üksnes informatsiooni sisestamiseks . Juhtregistrisse TRIS saab info ainult salvestada . Selles registris olev informatsioon määrab informatsiooni liikumise suuna GPIO-registri viikudel GP<arv> - GP<arv> . Joonisel <arv> on näidatud , kuidas ühendatakse omavahel üks järk GPIO- ja TRIS-registrites ning kuidas on lahendatud lülituse väljundaste . Viimase moodustab väljatransistoride paar ( VT<arv> , VT<arv> ) koos dioodkaitselülitusega ( VD<arv> , VD<arv> ) .  Joonis <arv>. Sisend-väljundviigu loogikalülitus Mikrokontrollerist väljastatav informatsioon puhverdatakse alati GPIO-registri vastavas järgus ( trigeris T<arv> ) . Mikrokontrollerisse sisestatavat informatsiooni ei puhverdata GPIO-registris , see suunatakse otse sisemisele andmesiinile ( Data Bus ) . Trigeri T<arv> ( kuulub TRIS-registrisse ) olek määrab , kas antud hetkel võib toimuda informatsiooni sisestamine ( T<arv> : = ” <arv> ” ) või väljastamine ( T<arv> : = ” <arv> ” ) . Mikrokontrolleri iga S/V-viigu infoedastuse suund on individuaalselt programmeeritav . Tähistused : W R Port - juhtsignaal “ Salvestus porti ” ( trigerisse T<arv> salvestatakse andmesiinil Data Bus oleva biti väärtus ) ; RD Port - juhtsignaal “ Lugemine pordist ” andmesiinile Data Bus suunatakse S/V-viigul oleva biti väärtus ) ; TRISi - juhtsignaal , “ Salvestus TRIS-registrisse ” TRIS-registri järku i salvestatakse W-registrist biti WReg väärtus ) . Tabelis <arv> on toodud mikrokontrollerite PIC<arv>F<arv>/<arv> S/V-viikudele edastatavate signaalide loetelu ja nende funktsionaalne toime . Nagu tabelist nähtub , kasutatakse mikrokontrolleris polüfunktsionaalseid S/V-viike , s.t erinevates talitlusrežiimides võib üks ja sama viik olla kasutusel erineval eesmärgil . MIKROKONTROLLERI KÄSUSTIK JA KÄSKUDE TÖÖTLEMINE Mikrokontrollerite käsustikud on väga lihtsad . Tänu käsustiku ortogonaalsele ( sümmeetrilisele ) ülesehitusele saab kõikide operatsioonide tarvis kasutada kõiki registreid ja adresseerimise viise . Kokku sisaldab mikrokontrolleri(te) käsustik <arv> erinevat käsku . Kasutatakse <arv>-bitise formaadiga käske , mida vastavalt neis sooritatavatele infoteisendustele ( operatsioonidele ) võib jagada kolme rühma : <arv>. Bait-orienteeritud operatsioonid ( <arv> käsku ) . <arv>. Bitt-orienteeritud operatsioonid ( <arv> käsku ) . <arv>. Operatsioonid literaalidega ja juhtimisoperatsioonid ( <arv> käsku ) . Programmi täitmist ohjab <arv>-bitine ( mõnes kiibis <arv>-bitine ) käsuloendur ( PC ) . Töödeldavaid käsukoode säilitatakse käsuregistris ( IR ) . Käskude töötlusel kasutatakse lihtsat kaheastmelist sünkroonset käsukonveierit . Käsukonveieri esimene aste sooritab käsuvõtte , teine aste aga käskude töötlust . Selles toimubki käsukoodiga määratud infoteisenduse sooritamine . Valdav osa käske viibib käsukonveieris kaks käsutsüklit ( IC ) . Ideaalsel juhul väljastab käsukonveier igal käsutsüklil ühe käsutöötluse tulemi . Käsutsükkel ise koosneb neljast taktigeneraatori taktist ( Q<arv> , Q<arv> , Q<arv> , Q<arv> ) . Üldjuhul kulutatakse ühe käsu töötlemisele käsukonveieris kaheksa takti , erandi moodustavad vaid käsud , mis ohjavad programseid hargnemisi . Igal käsutsükli taktil Q<arv> suurendatakse käsuloenduri olekut “ +<arv> ” võrra ( PC : = PC + <arv> ) . Kui on tegemist käsuvõtutsükliga , siis toimub sellele järgnevatel taktidel ( Q<arv> ja Q<arv> ) käsu lugemine programmimälust . Käsuvõtutsükli lõpetab takt Q<arv> , mille jooksul salvestatakse mälust loetud käsukood käsuregistrisse ( IR ) . Käsu töötlustsüklis toimub taktil Q<arv> käsuregistris asuva käsu käsukoodi dekodeerimine , sellele järgneb käsukoodiga ettenähtud infoteisenduse sooritamine . Kui käsus kasutatakse ka operande , siis taktil Q<arv> viiakse läbi operandivõtt , taktil Q<arv> toimub infoteisendus operandidega ning töötlustsükli lõpetab takt Q<arv> . Sellel taktil salvestatakse saadud tulem andmemällu . Tabel <arv> PIC<arv>F<arv>/<arv> mikrokontrollerkiipide sisend-väljundviikude otstarve  Viigu mnemooniline tähistus Viigu signaali tähis Sisendi liik Väljundi liik Funktsionaalne kirjeldus GP<arv>/ICSPDAT GP<arv> TTL CMOS Kahesuunaline programmeeritav S/V-viik ICSPDAT ST CMOS Sidusrežiimis programmeerimisel andmete viik GP<arv>/ICSPCLK GP<arv> TTL CMOS Kahesuunaline programmeeritav S/V-viik ; väljumine suikerežiimist ICSPCLK ST CMOS Sidusrežiimis programmeerimisel takteerimissignaali viik GP<arv>/T<arv>CKI/ FOSC<arv> GP<arv> TTL CMOS Kahesuunaline programmeeritav S/V-viik T<arv>CKI ST Taimeri TIM takteerimise viik FOSC<arv> CMOS Taktigeneraatori väljundviik GP<arv>/ MCLR/ Vpp GP<arv> TTL Ühesuunaline programmeeritav sisendviik MCLR ST Lähtestuse viik Vpp HV Programmeerimise režiimis programmeerimispinge viik Vdd Vdd P Toitepinge Vdd viik Vss Vss P Toitepinge Vss ( GND ) viik Tabelis <arv> on kasutatud järgmisi tähistusi : TTL - TTL-pingenivoodega sisend ; HV - kõrgendatud pingenivoo ( +<arv>V ) ; CMOS - CMOS-pingenivoodega väljund ; P - mikrolülituse toitepinge ; ST - Schmitti trigeriga varustatud sisend . Juhul kui käsukonveierisse siseneb aga käsk , mis muudab käskude täitmise järjekorda , siis selle käsu töötlemine erineb eelkirjeldatust . Joonisel <arv> on kujutatud olukord , kus programmis käskudele I<arv> ja I<arv> järgneb siirdekäsk I<arv> , mis muudab programmi edasist kulgu . Siirdekäsu toimel peab programmi töötlemine jätkuma käsult Ix , mitte aga programmis käsule I<arv> vahetult järgnevalt käsult I<arv> . Antud juhul toimub , pärast käsu I<arv> töötlustsüklisse jõudmist ka käsu I<arv> võtt , aga niipea , kui käsu I<arv> töötlustsüklis tuvastatakse , et tegemist on siirdekäsuga , lõpetatakse käsu I<arv> teenindamine ning käsk kõrvaldatakse käsukonveierist . Samaaegselt käsu I<arv> kõrvaldamisega toimub käsu Ix käsuvõtt . Erinevalt käskudest I<arv> ja I<arv> kulub siirdekäsu täitmisele mitte kaks , vaid kolm käsutsüklit ( IC<arv> , IC<arv> , IC<arv> ) . Käsu Ix tulem väljub käsukonveierist hilistumisega , sisuliselt tähendab see aga käsukonveieri tootlikkuse langust . Mikrokontrolleri käsustikus on siiski vaid kolm käsku ( alamprogrammikutse - CALL , naasmine - RETLW ja tingimusteta siire - GOTO ) , mille täitmiseks vajatakse kolme käsutsüklit .  Joonis <arv>. Mikrokontrolleri PIC<arv>F<arv>x käsukonveieri talitluse näide MIKROKONTROLLERLÜLITUSTE MÕNINGAID TÄIENDAVAID FUNKTSIONAAL-KONSTRUKTIIVSEID OMADUSI Vaatamata lihtsusele ja optimeeritud riistvarale , on PIC<arv>F<arv>x-sarja mikrokontrollerid varustatud mitmete kasulike lisafunktsioonidega , mis tõstavad lülituste töökindlust , vähendavad energiatarvet ning loovad eeldused kontrollerkiipide kasutamiseks odavate ja minimaalse lisakomponentide arvuga rakenduste loomisel . Kui piirduda vaid kõige olulisemate lisafunktsioonidega , millega Microchip on varustanud oma tillukesed kontrollerlülitused , siis ei saa nimetamata jätta järgmisi : <arv>. Valvetaimeri olemasolu . <arv>. Mikrokontrollerlülituse automaatne lähtestus kiibi pingestamisel . Selleks on kiibis spetsiaalne POR-lülitus ( Power-on Reset ) . See lülitus ei luba kontrolleri loogikalülituste talitluse alustamist enne , kui kiibi toitepinge Vdd on saavutanud nominaalväärtuse . Automaatselt lähtestatakse mikrokontrollerlülitus ka juhul , kui toitepinge langeb allapoole lubatavat pingenivood . <arv>. Lähtestustaimeri ehk DRT ( DRT - Device Reset Timer ) olemasolu . Lähtestustaimeri poolt tekitava viite ( kestusega ligikaudu <arv> millisekundit ) abil tagatakse , et kiibi pingestamisel ei väljutaks lähtestusolekust ( Reset-olekust ) senikaua , kuni toitepinge ei ole saavutanud ettenähtud väärtust ning kiibi taktigeneraatori talitlus ei ole stabiliseerunud . <arv>. Energiasäästu(suike)režiimi olemasolu . Kui nominaalrežiimis , toitepingel <arv>V ja taktsagedusel <arv> MHz , tarbib mikrolülitus voolu ligikaudu <arv> mikroamprit , siis suikerežiimis langeb kiibi energiatarve <arv> nanoamprini . Siirdumine suikerežiimi toimub programselt vastava käsu abil . Kuigi enamik mikrokontrolleri loogikalülitusi lakkab suikerežiimis talitlemast , jääb valvetaimer siiski tööle . Antud režiimist väljumine võib toimuda mitmeti ( rakendades kiibile väliselt lähtestussignaali Reset , kasutades valvetaimerit või muutes signaalide olekut S/V-viikudel ( GP<arv> , GP<arv> või GP<arv> ) , muidugi kui vastav “ äratusviis ” on ette nähtud ) . <arv>. Koodikaitse rakendamine . Kui kontrollerlülituse spetsiaalses nn konfiguratsioonijuhtsõnas on koodikaitse tunnus aktiveeritud , siis blokeeritakse automaatselt programmimälu sisu lugemine kiibiväliselt . See funktsioon on eriti oluline infoturbe aspektist . <arv>. Sidusrežiimis toimuv programmimälu sisu ( ümber ) programmeerimine . Mikrokontrollerlülituse väärtuslikuks omaduseks on võimalus programmeerida või ümber programmeerida selle programmimälu olukorras , kui kiip on juba monteeritud (sard)süsteemi . Mikrokontrolleri programmeerimisel vajatakse ainult kahte sisendviiku , neist ühe kaudu edastatakse jadamisi mällu salvestatavaid ( programmeeritavaid ) andmeid ( viik GP<arv>/ICSPDAT ) ja teise kaudu salvestust sünkroniseerivad taktsignaalid ( viik GP<arv>/ICSPCLK ) . On vajalik , et programmeerimise režiimis oleks viigule GP<arv>/MCLR /Vpp antud kõrgendatud pingenivoo ( Vpp = +<arv>V ) . <arv>. Mikrokontrollerkiibi tavatult väike jälgpind . <arv>-viigulise SOT-<arv> kiibikorpusesse monteeritud mikrokontrolleri jälgpind ei ületa <arv>,<arv> mm<arv> ( <arv>,<arv> × <arv>,<arv> mm ) . <arv>. Mikrokontrollerite kasutajate seisukohalt on väga oluline , et firma Microchip Technology Inc. pakub lisaks mikrokontrollerkiipidele mitmeid tark- ja riistvaralisi arendusvahendeid , nagu assemblereid , kompilaatoreid , linkureid , simulaatoreid , emulaatoreid , sidusemulaatoreid , programmaatoreid ja terviklikke demonstratsioon- ning hindamiskomplekte . Mis puutub PIC<arv>F<arv>x-sarja mikrokontrollerite kasutusvaldkondadesse , siis need võivad olla õige erinevad . Neid on väga mugav ja otstarbekas kasutada väga mitmesuguste turvasüsteemide koosseisus või kiipkaartide valmistamiseks . Kindlasti vajatakse seda tüüpi kontrollereid väga palju rakendustes , kus tegeletakse loogikakontrollerite tüüpiliste ülesannete lahendamisega . Lai tööpõld ootab uusi PIC-mikrokontrollereid ees süsteemides või seadmetes , kus esinevad ranged piirangud energiatarbele , gabariitidele või massile , s.t mitmesugustes aerokosmilistes objektides , mehhanotroonikas , robootikas jne. On avaldatud arvamust , et Microchipi “ putukad ” võivad hakata pakkuma arvestatavat konkurentsi praegu küllaltki suurtes mahtudes toodetavatele odavatele , kuid piiratud jõudluse ja funktsionaalsete võimalustega <arv>-bitistele mikrokontrolleritele . Nii mitmedki firmad , kes tegelevad hinnatundlike ja väikeste mõõtmetega kompaktsete elektroonikaseadmete valmistamisega , on ilmutanud otsest huvi uute mikrokontrollerkiipide vastu . PIC-mikrokontrollerite konkurentsivõimet on alati toetanud Microchipi kontrollerkiipidele iseloomulik hea jõudluse-maksumuse suhe . See tendents on säilinud ka PIC<arv>F<arv>x-sarja kiipide puhul . Nii maksid <arv>. aasta algul kõige piiratumate võimalustega PIC<arv>F<arv> kiibid kõigest <arv>,<arv> dollarit ja kõige võimsamad PIC<arv>F <arv> kiibid vaid <arv>,<arv> dollarit . Õige pea on turule oodata veelgi paremate näitajatega mikrokontrollerkiipe PIC<arv>F<arv> ja PIC<arv>F<arv> , mis sisaldavad mitte enam lihtsat analoog-võrdluslüli , vaid korralikku analoog-digitaalmuundurit . KOKKUVÕTTEKS Microchip Technology Inc. poolt välja töötatud polüfunktsionaalsed kõrge jõudluse , madala energiatarbe ja ülipisikese jälgpinnaga PIC<arv>F<arv>x-sarja mikrokontrollerid olid <arv>. aastal ühed tähelepanuväärsema ja huvitavama mikroarhitektuurse lahendusega <arv>-bitised kontrollerkiibid . Arvestades aga praegust äärmiselt tihedat konkurentsi mikrokontrollerite turul , võib eeldada , et ilmselt ei õnnestu Microchipil mitte eriti kauaks säilitada maailma väiksemate mikrokontrollerite valmistaja tiitlit .  Erki Eessaar , TTÜ informaatikainstituut SISSEJUHATUSEKS Kõik infotöötlejad teavad , et iga uue infosüsteemi loomine on nii selle tegijatele kui ka tellijatele vägagi tõsine probleem . Tihtipeale lõpeb pealtnäha suhteliselt lihtsa käitlussüsteemi paikapanek ja realiseerimine lausa fiaskoga . Sealjuures jääb kõrvaltvaatajal mulje , et noh , mis seal siis nii teha oli , asi peaks ju suhteliselt standardne olema , võta ainult kätte ja tee ära . Eesti ajakirjanduseski on viimastel aegadel valgustatud päris mitme üpris kuluka ja sisuliselt ebaõnnestunud projekti kulgu ja mõlema poole arvamusi . Arvamustest on näha , et tegelikult ei süüdistata tegijaid ebakompetentsuses , vaid enamasti algses planeerimisperioodis juhtunud probleemi keerukuse alahindamises . Kas selline saatus on süsteemide tegemisel paratamatus ? Esitame siinkohal mõtete ärgitamiseks ühe tsitaadi : “ Põhimõtteliselt ei saa ükski kirjeldus olla täielik , ja kui ta seda ei ole , siis ei saa olla ka ühetähenduslik , sest ühetähenduslik on ainult tegelik reaalsus ise lõpliku piirjuhtumi mõttes ... Järelikult kõik katsed süstematiseerida termineid teaduslikus mõttes on asjatud , sest mitmetähenduslike määrangutena saab neid rühmitada erinevateks süsteemideks ning ühtset ühetähenduslikku süsteemi on siin võimatu saavutada . Tuleb tunnistada , et keele terminitele on omane just süsteemitus . Need ei ole muud kui kunstilised kujundid , mis kord tekivad , kord kaovad sõltuvalt ühe- või teistsugustest vajadustest . Öeldust järeldub , et ühtede või teiste mõistete tähistamiseks vajalike skeemide ja nende kombinatsioonide loomine ei ole teadlaste ülesanne , vaid sobib kunstnikele . Kunstniku tegevusväljaks on just mitmetähenduslikkus ning selle tegevuse tingimuseks on piiramatu vabadus ja sõltumatus igasugusest üheselt määratud korrast . ” Kas tuleb tuttav ette ? Olles osalenud paljude projektide realiseerimisel , julgen väita , et ei leidu ühtegi projekti , milles me ei kuuleks projekti suhteliselt kauges staadiumis tellijalt umbes taolist väljendit : “ Tegelikult mõtlesin ma seda asja hoopis niimoodi ... ” Noh , kas infosüsteemide tegijad peaksid siis kunstnikud olema või ? Sellest oleks ikkagi vähe kasu , sest süsteem peab ju üheselt töötama . Tõlgendusvabadus , mis sobib kunstiteose puhul , ei sobi mingil juhul infosüsteemides . Muide , see eespool toodud tsitaat pärineb eesti soost mehe Jakob Linzbachi sulest ja on kirja pandud juba aastal <arv> ( !! ) . Linzbach oli hariduselt raudteetehnik , kes väga sügavalt mõtles universaalkeele probleemide üle ja avaldas Peterburis oma mõtteid jäädvustava venekeelse raamatu pealkirjaga “ Filosoofilise keele põhimõtted . Täppiskeeleteaduslik katsetus ” . Kõikidele eesti informaatikutele ja arvutimeestele peaks pakkuma tõsist huvi asjaolu , et Jakob Linzbach esitas oma raamatus vägagi korrektse n-ndsüsteemide kasutamise idee . Ta märgib , et ühendsüsteem vastab loendamisele ja annab küll maailma asjadest täpse pildi , kuid on tänu oma esituse pikkusele praktikas kõlbmatu . Linzbachi lemmikuteks olid kahend- ja kaheksandsüsteem ( ! ) . Kahendsüsteemi suureks plussiks on see , et selles saab teha kõiki arvutusi ja see võimaldab andmetest kaotada tavakeelele kõnest arusaamiseks nii vajaliku liiasuse . Linzbach ennetas seega informatsiooniteooria loojate Hartley ja Shannoni esimesi töid ideeliselt õige mitme aastaga . ( Praegu loetakse teda semiootika klassikute hulka kuuluvaks . ) Huvitav on seegi , et Linzbach toob oma raamatus näiteid kahendsüsteemis arvutamise kohta ( liitmine , lahutamine , korrutamine ja jagamine ) . Asja lähemalt uurides selgus , et esimestena hakkasid vist neid süsteeme Eestis pruukima Tartu mehed Ülo Kaasik ja Leo Võhandu , kes <arv>. aasta <arv>. jaanuaril asusid Moskvas tööle arvutil STRELA . Tallinnas alustas “ Punase Reti ” konstrueerimisbüroos arvusüsteemide käsitlemist Harry Mägi <arv>. aastal . Tehnikaülikoolis hakati diskreetset tehnikat tutvustama alles <arv>. aastal , mil Harry Mägi asus vastava distsipliini õppejõu kohale . Linzbachi poolt juba tollal väga selgelt tunnetatud tavakeele sõnade mitmetähenduslikkus ja subjektiivsus ( igal kõnelejal on oma lause iga sõna jaoks oma semantiline väli ! ) annab ka vastuse , miks nende pealtnäha nii lihtsate süsteemide tegemine nii tihti uppi lendab . Projektis osalejate mõttemudelid maailma nähtuste kohta on kõik sügavalt subjektiivsed ja nende ühismõõtsustamine ning kõikidele sobivasse mudelisse sobitamine koos järgneva arvutil realiseerimisega on ikkagi tõsine töö . Uuemal ajal ongi seda mõtteliselt erinevate mudelite kirjapanekut hakatud nimetama vaadete süsteemi kirjeldamiseks . Selle töö juures on tasapisi suudetud luua informaatikute elu mingis mõttes kergendav UML-keel . Järgmises jaotises annamegi ülevaate UMLil baseeruvatest kirjeldustehnikatest ja nende puudustest . Sellele järgneb ühe omapärase metoodika nn süsteemimaatriksi ( SMX ) appivõtmine . Seeniorautor tutvus selle süsteemi jaoks tervikpilti anda üritava metoodikaga juba <arv>. aastal . Tampere ülikoolis viibides leidsin ootamatult prof Pertti Järvise konspektist kummalise maatriksskeemi , mis äratas tähelepanu . Saanud Pertti käest tunnilise algõpetuse , kasvas isu veelgi . Tollase Popovi-ühingu kaudu õnnestus end järgmisesse Rootsi-ekskursiooni lülitada ja nii kohtusingi esimest korda suure isemõtleja Christer Jäderlundiga . Too mees oli tollal Rootsis väljaspool akadeemilisi ringkondi juba parajalt kuulus , nii et kui ma Janis Bubenkole ja Lars-Erik Thorellile rääkisin oma kohtumisest Jäderlundiga , siis paluti meid kahekesi professuuri klubisse pidulikule lõunasöögile . Tulemuseks oli see , et SMX kohta peeti Stockholmi ülikoolis ja tehnikaülikoolis rida loenguid . Jäderlundi meetodi põhihädaks oli see , et prototüüp oli kirjutatud DOSis ja tarbijaliides oli kaunikesti kohmakas . Alles teise fanaatiku Danny Kohni projektiga liitumine pani <arv>. aastatel asja kiiremini arenema . Pärast Jäderlundi surma kirjutas Kohn kogu värgi ümber Pythonisse . Sellega tekkis korralik paljuaknaline Windowsis töötav variant , millest ka meie loos pikemalt juttu tuleb . Seeniorpartner on veendunud SMXi kasulikkuses ja üritanud seda meetodit ka Eestis käivitada . Ristsõnaprogrammeerimisest oli juttu juba <arv>-<arv> ajakirjas Tehnika ja Tootmine ilmunud seerias “ Uued hoovused inseneriasjanduses ” . <arv> aastate algul korraldasime seminari TTÜs ( Jäderlund , Kohn , Võhandu ) ning mõnel aastal õpetasime ka DOS-varianti tudengitele . Nüüd on uus Pythonis kirjutatud SMX-variant igati tähelepanu vääriv . Loodame , et see artikkel ehk veel mõne poolehoidja värbab . INFOSüSTEEMI MITMEVAATELINE KIRJELDAMINE JA SELLEST TULENEVAD PROBLEEMID Infosüsteemi kirjeldatakse erinevate vaadete kaudu , nagu andmevaade , funktsionaalne vaade , sündmusvaade , mis peavad moodustama loogilise terviku . Neid vaateid tuleb modelleerida mitmel tasemel . Infosüsteemi mitmevaatelise ja mitmekihilise kirjelduse näiteks on J. Zachmani infosüsteemi arhitektuuri raamistik [ Zachman ] . Kaasaegses infosüsteemi arenduses on objekti- , protsessi- ja sündmuskeskne modelleerimine kasutusel kompleksselt . Süsteemi kirjeldamiseks kasutatakse visuaalseid modelleerimiskeeli , mille de facto standardiks on kujunenud UML ( Unified Modelling Language ) . Levinud käsitluse kohaselt on süsteemi erinevate vaadete ( objekti- , protsessi- ja sündmusvaade ) ühel mudelil esitamine raske , sest inimene ei suuda üldjuhul mõelda korraga kolmest aspektist [ Mikli , <arv> , lk <arv> ] . Seetõttu on erinevat tüüpi vaadete esitamiseks välja töötatud erinevat tüüpi mudelid . Iga mudel pakub vaate mingile kindlale süsteemi aspektile . Süsteemist tervikpildi saamiseks tuleb tutvuda kõigi süsteemi kirjeldavate mudelitega . Muidu juhtub nii nagu viie pimeda mehega india muinasjutus , kes katsusid elevanti . Elevandi rollis on antud juhul vaatluse all olev süsteem . Üks pime puudutas elevandi sabaotsa , teine jalga , kolmas kõrva , neljas lonti , viies külge . Sõltuvalt sellest , millist kehaosa nad puudutasid , arvasid nad , et elevant sarnaneb luuaga , sambaga , lootoselehega või köiega . Kõigil neil oli mingil määral õigus , kuid keegi neist ei näinud tervikpilti . Inimestel kujuneb üldjuhul siiski välja eelistus , millistest vaadetest alustada süsteemi kirjeldamist või süsteemiga tutvumist . Näiteks mõned võivad süsteemiga tutvumisel eelistada uurida selle funktsioone ja lugeda kasutusjuhtude mudelit . Teised aga alustavad tutvumist domeeni- või andmemudelist , et saada teada süsteemi jaoks olulised mõisted ning nende seosed ja tähenduse . Süsteemi kirjeldavad mudelid peavad olema süntaktiliselt ja semantiliselt korrektsed ning kooskõlas teiste sama süsteemi kirjeldavate mudelitega . Paraku pole paljudes modelleerimisvahendites mudelite kontrollile piisavalt tähelepanu pööratud . Automaatse kontrolli võimalus kas puudub täielikult või ei leia see kõiki vigu . Mudelite kontroll on sellisel juhul aega- ja tähelepanu nõudev manuaalne tegevus , kus vead võivad ka kahe silma vahele jääda . Kui vead kanduvad edasi järgmistesse arendusetappidesse , muutub nende parandamine aeganõudvamaks , kulukamaks ja keerukamaks . Mudelite kooskõla kontrolli muudab keerukamaks ka asjaolu , et mudel koosneb tavaliselt joonistus- või modelleerimisvahendis koostatud diagrammidest ja tekstilistest spetsifikatsioonidest , mis on enamasti loodud mingi teise tarkvara abil . Näiteks diagrammide koostamiseks kasutatakse selliseid programme nagu Rational Rose , Visio või ArgoUML , tekstiliste kirjelduste koostamiseks aga tarvitatakse MS Wordi või Open Office Writer'it . Mõnikord võivad mudelid eksisteerida vaid paberile visandatud joonistena . Muutes ühte mudelit , on vaja muuta ka teisi , kuid sageli jääb see tähelepanematusest või ajapuudusest tegemata . Sellest tulenevad ka kooskõlalisuse vead . Näiteks lisades süsteemianalüüsi käigus olemi-suhte diagrammile uue olemi või atribuudi , tuleb kontrollida , et kasutusjuhtude mudelis leiduksid kasutusjuhud , mis näeksid ette antud olemile või atribuudile vastavate andmete lisamise , lugemise , muutmise ja kustutamise . Samuti tuleb üle vaadata ja täpsustada süsteemi operatsioonide lepingud . Mudelite omavaheliste seoste õpetamine on oluline osa infosüsteemi projekteerimise õpetamisest . Samuti peaks infosüsteemi projekteerija olema oma väljendustes täpne ning suutma leida ja analüüsida erandolukordi . Oleks hea , kui modelleerimiseks kasutatav CASE-tarkvara juhiks mudeli muudatuse järel kohe tähelepanu muudatusest tingitud teistele vajalikele muudatustele nii samas mudelis kui teistes sama süsteemi kirjeldavates mudelites . Samuti võiks tarkavara anda soovitusi mudeli täiendamiseks ja seni uurimata erijuhtumite käsitlemiseks . Paraku on modelleerimisvahendite võimalused üsna piiratud ja nii kulub juhendajal tublisti aega selliste ebakõlade otsimisele , mille tekkimist võiks automatiseerimisega vältida ja mida saaks tehtud tööst automaatselt otsida . Samuti võib õppejõupraktika põhjal öelda , et koostatavate mudelite suur hulk ja eripalgelisus sunnib õpilast probleemide ja lahenduste üle sisulise järelemõtlemise asemel kulutama palju aega modelleerimiskeele õppimisele . Süsteemist kõiki aspekte arvestava , tervikliku e holistliku pildi saamiseks ja seoste tajumiseks peab huviline mudeleid sisaldavaid trükitud dokumente edasi-tagasi läbi lappama . Ta peab orienteeruma kümnete või isegi sadade lehekülgede seas . Kui mudelid on elektroonilistes dokumentides , hõlbustab erinevate osade vahel liikumist hüperlinkide kasutamine . Kõik taolised probleemid ja puudused on argumendiks neile , kes ei pea süsteemi modelleerimist oluliseks . Kontrollifunktsioonide puudulikkus on üks kriteeriume , mis põhjustab CASE-vahendi kasutamisest loobumist . [ Dori , <arv> ] juhib tähelepanu , et eelnevalt mainitud probleemid on tingitud sellest , et süsteemi üritatakse kirjeldada paljude erinevat tüüpi mudelitega , mis muudavad süsteemist tervikpildi saamise raskeks ja aeganõudvaks . Lahenduseks võiks olla paljude erinevate mudelitüüpide kasutamise asemel ühe mudelitüübi loomine , mis võimaldaks süsteemi kirjeldada terviklikult e holistlikult . [ Peleg &amp; Dori , <arv> ] kirjeldavad eksperimenti , milles võrreldi ühte mudelitüüpi kasutava arendusmetoodika põhjal koostatud mudeleid ja mitmeid mudelitüüpe kasutava arendusmetoodika põhjal koostatud mudeleid . Võrreldi nii süsteemi kirjeldamisel tehtud vigade hulka ja iseloomu kui ka süsteemi kirjelduse arusaadavust . Analüüsi tulemusel jõuti järeldusele , et ühe mudelitüübi kasutamise korral oli süsteemi kirjelduse kvaliteet oluliselt parem kui mitme mudelitüübi kasutamise korral . Süsteemi kirjelduse arusaadavuse puhul tõdeti , et on vaja täpsemat uuringut , kuid näib , et ühe mudelitüübi kasutamise korral on kirjeldus arusaadavam . SüSTEEMIMAATRIKS Eelnevalt mainitud probleemidest ollakse muidugi juba ammu teadlikud . Järgnevalt tutvustatakse holistliku süsteemiarenduse metoodikat ja seda toetavat tarkvarasüsteemi . Esimese versiooni töötas juba <arv>. aastatel välja rootsi teadlane Christer Jäderlund . Artiklis pakutav süsteemimaatriksi ja holistliku metoodika kirjeldus põhineb peamiselt allikatel [ Jäderlund , <arv> ] ja [ Systematik ] . Holistlik süsteemiarenduse metoodika võimaldab süsteemi arendamisel kasutada loomulikku keelt , kuid samal ajal tagada süsteemi väga tugev sisemine kooskõla . Meetodit võib kasutada süsteemiprobleemide lahendamisel , nagu näiteks info- või automaatjuhtimissüsteemi kirjeldamiseks , aga ka infotööga mitteseotud tööprotsesside kirjelduste esitamiseks ja nende korrektsuse kontrolliks . Seda võib kasutada ka näiteks seaduste hindamiseks , et teha kindlaks , kas seaduses ettenähtud menetlusi saab läbi viia ja ega erandjuhtumeid pole jäetud käsitlemata . Süsteemi kirjeldatakse mitmevaateliselt , kasutades nn süsteemimaatriksi t ( ingl k System Matrixehk SMX ) ( vt joonis <arv> ) , milles on erinevad vaated süsteemile esitatud kompaktsel ja ülevaatlikul kujul .  Kataloog A Objektid Kataloog C Kontrolltingimused Kataloog B Funktsioonid Väli <arv> Väli <arv> Kataloog D Kontrollfunktsioonid Väli <arv> Väli <arv> Joonis <arv>. Süsteemimaatriksi struktuur Huvilised võivad süsteemimaatriksi koostamiseks , redigeerimiseks ja analüüsimiseks loodud programmi nimega SystemSpecifier alla laadida aadressilt <hyperlink> Programmi levitatakse GNU üldise avaliku litsentsi alusel , mis garanteerib kasutajatele vabaduse seda tarkvara levitada ja modifitseerida . Tarkvara kasutamise õpetuse ja süsteemimaatriksi põhimõtete kirjelduse leiab huviline programmi arendava firma kodulehelt : // <hyperlink> Süsteemimaatriksis näidatakse , millised süsteemi elemendid on kirjeldatava süsteemiosa jaoks olulised ja kuidas nad on omavahel seotud . Süsteemi elementideks on funktsioonid , funktsioonides kasutatavad objektid ning tingimused , mis peavad olema täidetud , et funktsiooni saaks täita . Objektid on füüsilised , käegakatsutavad objektid või abstraktsed objektid . Objektid on funktsioonide sisendiks ja väljundiks . Funktsiooni väljundiks olev objekt võib olla mõne teise funktsiooni sisendiks . Funktsiooni täitmine loob tingimused järgmiste funktsioonide täitmiseks . Elemendid paigutatakse eraldi kataloogidesse . Süsteemi struktuur koosneb seostest nende elementide vahel . Kataloogidesse paigutatud elemente võib klassifitseerida ja lisada neile täiendavaid tekstilisi kirjeldusi . Süsteemimaatriksi võib esitada ka lihtsustatud kujul ( vt joonis <arv> ) , mis sisaldab ainult ühte funktsioonide kataloogi , kuhu oleksid koondatud funktsioonid nii kataloogist B kui ka C. Sellist maatriksi võimaldab kasutada ka programm SystemSpecifier .  Kataloog A Objektid Kataloog C Kontrolltingimused Kataloog B Funktsioonid Protsessimaatriks Kontrollimaatriks Joonis <arv>. Lihtsustatud süsteemimaatriksi näide Süsteemi kirjeldab tema funktsioonide hierarhia . Igale hierarhia elemendile võib vastavusse seada ühe süsteemimaatriksi lähtuvalt järgmistest põhimõtetest [ Jäderlund , <arv> , <arv>.<arv> ] : Iga funktsiooni saab täpsustada tase madalamal asuva süsteemimaatriksi abil . Igale süsteemimaatriksile , välja arvatud kõige kõrgema taseme maatriks , vastab tase kõrgemas süsteemimaatriksis üks funktsioon . Kui ülemiselt funktsioonide tasemelt kutsutakse välja madalama taseme funktsioon , siis selle töö lõppemisel jätkub töö sealt , kus see ülemisel tasemel pooleli jäi . Kõige madalama taseme maatriksites vastab igale funktsioonile üks atomaarne tegevus . Elementidevahelised seosed kirjeldatakse protsessimaatriksis ja kontrollimaatriksis . Maatriksi lahtrisse on lubatud kirjutada üks märk . Iga märk tähistab kindlat seose liiki . Aktiveeritud funktsioonid töötavad objektidega . Funktsioonide ja objektide vahelised seosed esitatakse nn protsessimaatriksis ( väli <arv> ja <arv> joonisel <arv> ) . Protsessimaatriksis näidatakse , millised objektid on milliste funktsioonide sisendiks ja väljundiks . Järgnevalt kirjeldatakse enamkasutatavaid seoste tähiseid . “ I ” tähistab , et funktsiooni sisendiks on vastav füüsiline objekt . “ O ” tähistab , et funktsiooni väljundiks on vastav füüsiline objekt . Näiteks funktsiooni “ ehita kast ” sisendiks võivad olla sirged naelad , lauajupid ja saag ning väljundiks kast , lauajuppide ülejäägid ja mõned kõveraks löödud naelad . “ U ” tähistab objekti muutumist funktsiooni tulemusena ja oleks samaväärne kombinatsiooniga “ IO ” maatriksi lahtris . “ i ” tähistab , et funktsiooni sisendiks on informatsioon vastava objekti kohta . Paraku ei paku SMX tähiseid , millega märgistada infoobjekti tekkimist , muutumist või kadumist funktsiooni täitmise tulemusena . Selliseid tähiseid oleks vaja , et kirjeldada infotöö tulemusi . “ x ” tähistab täpsustamata seost funktsiooni ja objekti vahel . Sellist seost tuleb edaspidi täpsustada . “ X ” seevastu tähistab teadaolevat , kuid edaspidi täpsustamata seost funktsiooni ja objekti vahel . Tingimused kontrollivad funktsioone ja varasemate objektidega toimunud operatsioonide tulemused loovad uusi tingimusi . Funktsioonide ja tingimuste vahelised seosed esitatakse nn kontrollimaatriksis ( väli <arv> ja <arv> joonisel <arv> ) . Kontrollimaatriksis näidatakse , millised tingimused peavad funktsiooni täitmiseks olema täidetud , ja kirjeldatakse funktsioonide täitmise järjekord . Süsteemimaatriksi koostamine ei nõua , et probleemi lahendamist peaks alustama algusest . Kõigepealt tuleb kirja panna , mida tead , ja seejärel mõttelõnga edasi harutades jõuda uute ideedeni . Oluline on , et maatriksisse lisataks õiget informatsiooni , kuid oluline pole selle lisamise järjekord . Süsteemimaatriksiga seotud korrektsuse ja terviklikkuse kontrollid juhivad tähelepanu aukudele ja vastuoludele mõttearenduses , mida arendaja saab jooksvalt parandada . Süsteemimaatriksi te haldamise programm võimaldab neid kontrolle automaatselt teha . Arvestades selle tegevuse sarnasust ristsõna lahendamisega , nimetatakse taolist lahenduse loomist ka ristsõnaprogrammeerimiseks . SÜSTEEMIMAATRIKSI NÄIDE Järgnevalt esitatakse näide mõõdukalt keeruka süsteemimaatriksi kohta ( vt joonis <arv> ) , millel kirjeldatakse lihtsustatult fragmenti üliõpilaste elektroonilise õpingukava esitamise süsteemist . Tallinna Tehnikaülikooli õppetegevuse eeskirja [ TTÜ ] kohaselt on õpingukava “ Õppuri poolt eelseisvaks semestriks valitud õppeainete loend , mida ta kohustub õppima ; õppekava läbimise individuaalne tee semestrite kaupa . ”   Objektide kataloog Tingimuste kataloog <arv> - Kell ( O ) <arv> - START <arv> - Semester <arv> - Ei ole õpingukava koostamise periood <arv> - Kasutajanimi ( V ) <arv> - On õpingukava koostamise periood <arv> - Parool ( V ) <arv> - Kasutajal on õigus süsteemi siseneda <arv> - Üliõpilane ( R ) <arv> - Kasutajal pole õigust süsteemi siseneda <arv> - Õpingukava ( R ) <arv> - Õpingukava on olemas <arv>- Õppekava ( R ) <arv> - Õpingukava ei ole olemas <arv> - Tüüpõpingukava ( R ) <arv> - Loo semestri tüüpõpingukava põhjal <arv> - Üliõpilase jooksva semestri number ( V ) <arv> - Alusta koostamist nullist <arv> - Õppeaine ( R ) <arv> - Moodul ( R ) <arv> - Õppeaine õpingukavas ( R ) Joonis <arv>. Süsteemimaatriksi näide Funktsioonide kataloogis tähistab “ L ” , et tegemist on loogikafunktsiooniga , mis kogub informatsiooni ja langetab selle põhjal otsuse . Lipik &lt; action &gt; tähistab , et see funktsioon on atomaarne tegevus , mida enam väiksemateks osadeks ei jagata . Lipik &lt; sub module &gt; tähistab , et antud funktsioon tuleb lahti kirjutada madalama taseme süsteemimaatriksina . Märk “ &gt; ” tähistab funktsiooni algust ja “ &lt; ” tähistab funktsiooni lõppu . Objektide kataloogis tähistab “ O ” üldist objekti , “ T ” tabelit , “ R ” kirjet ja “ V ” üksikut väärtust . Süsteemimaatriksist peaks saama genereerida struktuurse teksti ja isegi programmikoodi - see on maatriksi oluline omadus . Joonisel <arv> esitatud süsteemimaatriks kirjeldab järgmist protsessi : Kontrollitakse , kas on õpingukava koostamise periood . Kui on õpingukava koostamise periood , siis küsitakse kasutajalt kasutajanime ja parooli . Kui antud hetkel ei ole õpingukava koostamise periood , siis lõpetatakse töö . Kasutaja identifitseeritakse sisestatud kasutajanime ja parooli põhjal . Identifitseerimisprotsess on kirjeldatud alammoodulis . Kui kasutajal on õigus süsteemi siseneda , siis jätkatakse . Kui ei ole , siis lõpetatakse töö . Kontrollitakse , kas semestri õpingukava on olemas . Kui semestri õpingukava on olemas , siis avatakse olemasolev semestri õpingukava ja jätkatakse õpingukava muutmisega . Kui semestri õpingukava pole olemas , siis valitakse õpingukava loomise viis . Kui otsustatakse luua õpingukava tüüpõpingukava põhjal , siis jätkatakse alammoodulis . Kui otsustatakse luua õpingukava nullist , siis jätkatakse alammoodulis . Pärast õpingukava loomist jätkatakse selle muutmisega . Õpingukava muutmine on kirjeldatud alammoodulis . Nullist suurem number kontrollimaatriksis tähistab , et funktsiooni käivitamiseks peab vastav tingimus olema täidetud . Number null tähistab kontrollimaatriksis funktsiooni võimalikku reaktsiooni , mis loob tingimuse järgmiste funktsioonide käivitamiseks . Funktsioonide täitmise järjekorda näitavad kontrollimaatriksis olevad numbrid vertikaalses lugemise suunas . Funktsioonide täitmine algab sisendist ( ENTRY ) , kui on täidetud tingimus START . Kõigepealt täidetakse funktsioon järjenumbriga <arv> , siis <arv> jne. Kui vaadeldavas veerus ei leidu vaadeldavast järjenumbrist x enam ühtegi suuremat järjenumbrit , kuid järjenumbriga x samal real on kaks või rohkem nulli , siis funktsioonide kataloogis oleva vastava funktsiooni näol on tegemist otsustusfunktsiooniga , mille abil kontrollitakse mingi tingimuse täidetust ja otsustatakse , mida edasi teha . Näiteks joonisel <arv> on selliste funktsioonide nimed funktsioonikataloogis hallil taustal . Järjenumbrite lugemine jätkub valitud tingimusele vastavast kontrollimaatriksi veerust . Joonisel <arv> on tähistatud üks võimalik funktsioonide täitmise stsenaarium . Kontrollimaatriksis näitavad lugemise suunda nooled ja loetud lahtrid on hallil taustal .  Joonis <arv>. Ühe võimaliku stsenaariumi näide Järgnevalt on esitatud joonisel <arv> väljatoodud stsenaariumi tekstiline kirjeldus . ENTRY Funktsioon : Kas on õpingukava koostamise periood ? Täidetud tingimus : Antud hetkel on õpingukava koostamise periood . Funktsioon : Kas on kasutaja ? Täidetud tingimus : Kasutajal on õigus süsteemi siseneda . Funktsioon : Kas semestri õpingukava on olemas ? Täidetud tingimus : Semestri õpingukava on olemas . Funktsioon : Ava olemasolev õpingukava . Funktsioon : Muuda õpingukava . EXIT Joonisel <arv> on esitatud joonisel <arv> väljatoodud kirjeldus , mis on vormistatud programmis SystemSpecifier . Kontrollimaatriksis on “ <arv> ” asemel “ Y ” .  Joonis <arv>. Süsteemi kirjeldus SystemSpecifier programmis Süsteemimaatriks koondab erinevat liiki tavakeelseid mõtteid . Küsilause : “ Kas semestri õpingukava on olemas ? ” See on süsteemimaatriksis esitatud horisontaalselt . Selle lause põhjal luuakse funktsioonide kataloogis üks kontrollifunktsioon e loogikafunktsioon . Joonisel <arv> on need funktsioonid tähistatud tähega L ja nimed on esitatud hallil taustal . Pealause : “ Ava olemasolev õpingukava ” . See on süsteemimaatriksis esitatud horisontaalselt . Selle lause põhjal luuakse funktsioonide kataloogis üks käsitlusfunktsioon . Joonisel <arv> on need funktsioonid tähistatud tähega F. Järjestuslause : “ Enne toimub semestri õpingukava olemasolu kontroll ja siis avatakse semestri õpingukava ” . Selle alusel määratakse kontrollimaatriksis funktsioonide täitmise järjekord . Kõik süsteemi analüüsimise käigus formeeritud mõtted tuleb kirjutada süsteemimaatriksisse , kasutades süsteemi tellijate ja kasutajate sõnavara . Süsteemimaatriksi võib täita uue süsteemi loojate ja selle kasutajate suhtlemise käigus , et kirjeldada olemasolevate süsteemide probleeme või nõudmisi uuele süsteemile . Süsteemimaatriks on oluline nii mõtlemisprotsessi abistajana kui ka süsteemi kirjeldajana . Süsteemimaatriksisse võib tekkinud mõtted esialgu sisse kanda ilma paigutust jälgimata . Pärast maatriksi koostamist tuleks seda parema loetavuse huvides normaliseerida [ Jäderlund , <arv> , <arv>.<arv> ] . Normaliseerimine tähendab sisuliselt seda , et elemendid kataloogides ja seega ka read ning veerud maatriksis on sorteeritud vastavalt elementide kasutuselevõtu järjekorrale . Järgnev lihtsustatud näide demonstreerib , et süsteemimaatriksis saab kirjeldada ka tsükleid . Tegemist võiks olla õpingukava muutmist kirjeldava maatriksi alammaatriksiga , mis kirjeldab õppeainete valimist õpingukavasse . Kontrollimaatriksis olevate nooltega on märgitud üks võimalik funktsioonide täitmise järjekord . Tsükli tunneb normaliseeritud kontrollimaatriksist ära selle järgi , et mõnes reas jääb nullist paremale poole mõni nullist suurem number .   Objektide kataloog Tingimuste kataloog <arv> - Õppeaine ( R ) <arv> - START <arv> - Õpinguaine ( R ) <arv> - Leiti sobilik õppeaine <arv> - Moodul ( R ) <arv> - Ei leitud sobilikku õppeainet <arv> - Õppeaine õpingukavas ( R ) <arv> - Korrata otsingut <arv> - Kell ( O ) <arv> - Mitte korrata otsingut Joonis <arv>. Tsüklit sisaldava süsteemimaatriksi näide Järgnevalt on esitatud joonisel <arv> väljatoodud stsenaariumi tekstiline kirjeldus . ENTRY Funktsioon : Otsi õppeaine . Täidetud tingimus : Leiti sobilik õppeaine . Funktsioon : Lisa õppeaine õpingukavasse . Funktsioon : Kas korrata otsingut ? Täidetud tingimus : Korrata otsingut . Funktsioon : Otsi õppeaine . Täidetud tingimus : Ei leitud sobilikku õppeainet . Funktsioon : Kas korrata otsingut ? Täidetud tingimus : Mitte korrata otsingut . EXIT SÜSTEEMIMAATRIKSI EELISED Süsteemimaatriksi eelised , võrreldes teiste süsteemi kirjeldamise viisidega , on : Süsteemi spetsifikatsioon on kompaktne . Tänapäeva maailmas , kus probleemiks on sageli mitte informatsiooni puudus , vaid selle üleküllus , on konkreetsus ja täpsus vajalikud omadused . Süsteemimaatriksiga töötamisel on põhiliseks töövahendiks loomulik keel , mis võimaldab süsteemimaatriksit kasutada võimalikult laial inimeste ringil . Võrreldes visuaalsete modelleerimiskeelte poolt pakutavate suure hulga eritüübiliste diagrammidega , on süsteemimaatriksi esitus lihtsam ja seetõttu ka kergemini õpitav . Süsteemimaatriksis esitatud informatsiooni põhjal saab luua teisi kirjeldusviise . Näiteks saab selle põhjal genereerida funktsioonide hierarhia diagrammi , seisundidiagramme , tegevusdiagramme , andmevoodiagramme . Üks aspekt , kus praegune süsteemimaatriksi käsitlus vajaks edasiarendamist , on andmemudeli loomine süsteemimaatriksi põhjal . Praegu võimaldab süsteemimaatriks leida vaid olulised objektid . Andmemudeli koostamine jääb kasutaja ülesandeks . Süsteemimaatriks võimaldab testida süsteemi kirjelduse õigsust , täielikkust ning seostatust . SystemSpecifier programmis tähistatakse sellist kontrolli lühendiga CCC - Correctness , Completeness , Consistency . Programm võimaldab sellist kontrolli automaatselt läbi viia . Automaatse kontrolli omadus on eriti oluline algse planeerimise staadiumis , kus igaüks töötab veel oma sõnavara kasutades . Programm teatab kirjelduste koostamise käigus , mida peab veel küsima . SÜSTEEMIMAATRIKSI KONTROLLI REEGLID Edasi toome näited kontrolli reeglitest [ Jäderlund , <arv> , <arv>.<arv> ] põhjal . Kontrollimaatriksis peab igas reas olema vähemalt üks arv . Kui reas pole ühtegi arvu , siis pole määratud , millises järjekorras vastavat funktsiooni täidetakse , võrreldes teiste funktsioonidega . Igas kontrollimaatriksi veerus peab kõige suurem number olema kas : Reas , milles leidub ka number <arv>. Kõige viimases reas , mis vastab funktsioonist väljumisele ( EXIT ) . Iga käsitlusfunktsioon peab omama vähemalt ühte sisendit ja väljundit . Funktsioonide ja objektide seosed esitatakse protsessimaatriksis . Igale küsimusele peab olema kaks või rohkem vastust ja seega peab iga kontrollifunktsioon olema seotud vähemalt kahe tingimusega . Funktsioonide ja tingimuste seosed esitatakse kontrollimaatriksis . Iga objekti peab kasutama vähemalt üks funktsioon . Iga tingimus peab olema seotud vähemalt ühe funktsiooniga . Iga funktsiooni täitmiseks peab olema täidetud vähemalt üks tingimus . SÜSTEEMIMAATRIKSI LUGEMINE Süsteemimaatriksi üheks puuduseks on see , et kuigi lahendus on kirjeldatud kompaktselt , nõuab selle maatriksi lugemine harjumist . Muster “ Seitse pluss või miinus kaks ” [ Evitts , <arv> ] annab soovituse , et süsteemi kirjeldaval diagrammil peaks olema mitte rohkem kui <arv> <arv> omavahel loogiliselt seotud elementi , sest muidu muutub diagramm ebaülevaatlikuks . Ka holistliku metoodika autorid tõdevad , et isegi suhteliselt väikesest maatriksist on raske korraga ülevaadet saada , kui seal on näiteks <arv> elementi ja nendevahelist seost . Erinevad inimesed alustavad süsteemiga tutvumist erinevatest vaadetest . Mõni on harjunud kõrgtaseme ülevaate saamiseks uurima domeenimudelit või andmemudelit , teine aga süsteemi funktsioonide kirjeldusi . Süsteemimaatriksi kasutamine annab igale kasutajale samuti võimaluse valida vaate , mille põhjal ta kõigepealt süsteemiga tutvub . [ Jäderlund , <arv> ] soovitab , et maatriksiga tutvumist võiks alustada maatriksi nime ja kirjelduse vaatamisest . Seejärel võiks tutvuda funktsioonide kataloogiga . Edasi võiks uurida objektide kataloogi ja tingimusi , mis peavad olema täidetud funktsioonide käivitamiseks . Kataloogidega tutvumise hõlbustamiseks saab SystemSpecifier programmis kasutada objekte , funktsioone ja tingimusi vaadelda aga nii nimekirjana kui ka hierarhiana . Programm SystemSpecifier võimaldab kasutajal ka mudelit “ käivitada ” . See tähendab , et vastavalt kasutaja poolt antud tagasisidele käiakse süsteemimaatriksi põhjal läbi ja kuvatakse tegevusstsenaarium . Otsustuspunktides peab kasutaja otsustama , millised tingimused on täidetud ja millist võimalikku tegevuste rada pidi tuleb edasi minna . Loetavuse huvides võib elementide järjekorda kataloogides muuta . Vastavalt muutub ka ridade või veergude järjekord protsessi- ja kontrollimaatriksis . See võimaldab näiteks sorteerida funktsioone nende täitmise järjekorra järgi ja objekte nende funktsioonides kasutamise järjekorra järgi . MIDA SAAKS SÜSTEEMIMAATRIKSI TE HALDAMISE PROGRAMMIS PAREMAKS TEHA ? SystemSpecifier programmi praegusel versioonil ( ver <arv>.<arv>.<arv> ) on ka mitmeid puuduseid , mida edasine arendus võiks kõrvaldada . Programm ei võimalda genereerida süsteemi kirjeldust struktuurse tekstina ega ka programmikoodi . Programm võiks süsteemimaatrikseid hoida lokaalsete failide asemel hoopis serveril asuvas andmebaasis , et anda teistele programmidele lihtne ja mugav võimalus süsteemimaatrikseid kasutada ning võimaldada mitmel inimesel korraga süsteemimaatriksit vaadata ja sellega töötada . SÜSTEEMIMAATRIKSI KASUTAMISE ÕPETAMINE Süsteemimaatriksi kasutamisest oleks tulu ka süsteemi kirjeldamise õpetamisel , sest tarkvara annab õppijatele tagasisidet nende poolt süsteemi kirjeldamisel tehtud vigade kohta . Kuna süsteem annab õppijale kohe tagasisidet vigade kohta ja ütleb ka , mida tuleb parandada , siis eemaldab see õppeprotsessist vigade tegemise hirmu kui barjääri , mis takistab õppimist . Süsteemimaatriksi mõte ongi selles , et süsteemi kirjutajad saaksid lasta oma ideedel ja vaimuvälgatustel arendust tüürida , samal ajal kui tarkvara jälgib , et kirjeldus oleks korrektne ja kooskõlaline . Süsteemimaatriksi loomise ja kasutamise õpetamisel võib kasutada pedagoogilist mustrit Disaini-rakenda-disaini_ümber-rakenda uuesti . Kõigepealt peaksid õppurid süsteemi kirjelduse koostama süsteemimaatriksi abil . Süsteemimaatriksi kasutamine kinnistab neis teadmise , et erinevad süsteemi kirjeldavad vaated on omavahel seotud ja ühe vaate muutmine tingib parandusi ka teistes vaadetes . Seejärel võiks õppuritele näiteks tutvustada UML-keelt ja paluda kirjeldada sama süsteem UML-mudelite abil . Õppurid võiksid “ tõlkida ” süsteemimaatriksi erinevateks UML-mudeliteks . HOLISTLIKU SüSTEEMIARENDUSE PõHIMõTTED Süsteemi kirjelduse loomisel võib kasutada erinevaid mõtlemistehnikaid , kusjuures eesmärgiks on õppida kasutama holistlikku mõtlemist [ Jäderlund , <arv> , <arv>.<arv> ] . Kataloogipõhine mõtlemine . Maatriksit vaadeldakse kui objektide , funktsioonide ja tingimuste kataloogi . Stsenaariumikeskne mõtlemine . Mõeldakse erinevatele süsteemi kasutamise stsenaariumidele . Relatsiooniline mõtlemine . Mõeldakse erinevatele objektide , funktsioonide ja kontrolltingimuste vahelistele seostele . Funktsioonikeskne mõtlemine . Süsteemi püütakse luua olemasolevatest ja defineeritud alamsüsteemidest ( maatriksitest ) . Holistlik mõtlemine lubab kasutada kõiki eelnimetatud mõttetehnikaid läbisegi vastavalt vajadusele . Eesmärgiks on mõista süsteemi tõelist tähendust ehk “ süvastruktuuri ” , mis on muutumatu , sõltumata märgisüsteemist , mida selle kirjeldamiseks kasutatakse . Tänapäeval kasutatakse süsteemi modelleerimisel sageli visuaalseid modelleerimiskeeli , mille de facto standardiks on kujunenud UML . Selleks et süsteemi kirjeldada , peab kasutaja ära õppima veel ühe täiendava kunstliku keele , kusjuures selle keele sõnade tähendus ei ole alati väga täpselt määratud ( lugege näiteks [ Date , <arv> ] ) . Holistlik süsteemiarenduse metoodika aga käsitleb inimeste kõneldavat tavakeelt kui kõige tähtsamat programmeerimiskeelt [ Jäderlund , <arv> , <arv>.<arv> ] Eesmärkidelt ei erine holistlik süsteemiarendus teistest süsteemiarenduse meetoditest ( struktuurne analüüs/disain , objektorienteeritud analüüs/disain ) . Eesmärgiks on saavutada töötav süsteem . Üheks põhiliseks erinevuseks on süsteemi kirjeldamise viis . Holistliku süsteemiarenduse esimeses faasis , mida nimetatakse probleemorienteeritud arenduseks või ka üldiseks programmeerimiseks , luuakse põhimõttelised lahendused . Selles faasis toimub põhiline probleemide lahendamine ja luuakse lahendust kirjeldav üldine programm , mis esitatakse süsteemimaatriksite kujul . Süsteemiarenduse teises faasis toimub tehniline disain , mille käigus genereeritakse lahendust kirjeldava üldise programmi põhjal tehnilised definitsioonid ehk lahenduse struktuurne tekst . Seda saab omakorda kasutada arvutiprogrammi kirjutamiseks . Ühe võimalusena võib struktuurset teksti vaadelda kui PDL- ( Program Design Language ) keelset programmi kirjeldust , millest saadakse konkreetse keele keelekonstruktsioonide lisamise käigus arvutiprogrammi tekst . Programmi kirjeldus muutub koodi kommentaarideks [ McConnel , <arv> ] . Süsteemiarenduse kolmandas faasis toimub süsteemi üleviimine uude keskkonda , praktiline tutvustamine , lõplik testimine ja pideva kasutamise alustamine . Nagu kirjeldusest nähtub , peetakse oluliseks süsteemi üldmudeli loomist , mille põhjal on võimalik genereerida konkreetses programmeerimiskeeles tarkvara . Mõte , et tähtis pole mitte tarkvaramoodul , vaid süsteemi valmislahendus mudelite tasemel , langeb kokku infosüsteemide isearendamise [ Kuusik , <arv> ] ja mudelitel põhineva arhitektuuri ( ingl k Model Driven Architecture , MDA ) käsitlusega [ Leis , <arv> ] . Kummagi käsitluse kohaselt on süsteemi arendamise juures kõige tähtsam luua komplekt süsteemi kirjeldavaid mudeleid , millele mõne konkreetse rakenduskeskkonna ( CORBA , Java Beans , . NET , XMI/XML ) disainimustreid rakendades on võimalik saada töötav süsteem . Sellised üldised erinevate eluvaldkondade ( nt finantsvahendus , telekommunikatsioon , logistika jne ) kohta loodud mudelid on mustrid , mida võib erinevate arendajate vahel vahetada . Mitmed teisedki holistliku arenduse põhimõtted on igihaljad ning kasutusel ka kõige moodsamates süsteemiarenduse metoodikates : Süsteemi kasutaja ja infotehnoloogia spetsialisti tihe koostöö Süsteemi järk-järguline arendamine Peetakse täiesti loomulikuks , et nõudmised süsteemile ja süsteem ise pidevalt arenevad ja muutuvad Koostatavate süsteemi kirjelduste varajane testimine . Õigsust , täielikkust ning seostatust saab testida juba süsteemimaatriksis Taaskasutamine . Christopher Alexander sõnastas ühe igikestva arhitektuuri ja planeerimise printsiibi , milleks on osavõtuprintsiip . “ Kõik otsused , mida ehitada ja kuidas ehitada , on kasutaja kätes . ” [ Alexander et al , <arv> , lk <arv> ] . Ka tänapäeva infosüsteemide arendusmetoodikad , nagu näiteks nn sotsiotehniline perspektiiv [ Davis , <arv> ] , [ Kuusik , <arv> ] poolt kirjeldatud metoodika ja mitmesugused paindmetoodikad , peavad väga tähtsaks süsteemi tulevaste kasutajate võimalikult ulatuslikku kaasahaaramist süsteemi arendamisse . Holistlik süsteemiarendus peab oluliseks süsteemi järkjärgulist arendamist ning loomulikuks , et informatsioon ja teadmised süsteemi kohta ei teki ühekorraga . See on märkimisväärne , sest ajal , kui holistlik metoodika välja töötati , oli valdav süsteemi arendamine nn kose mudeli alusel . Kose mudeli kohaselt toimus üleminek ühelt süsteemiarenduse etapilt teisele , kui eelmise etapi tööd olid täiesti lõppenud , arvestamata , et teadmised süsteemi kohta täienevad aja jooksul . Holistlik arendusmudel sobib kokku Christopher Alexandri nägemusega selle kohta , kuidas inimesed peaksid oma elukeskkonda arendama . Tema arvates peavad inimesed järk-järgult lahendama enda ees seisvaid probleeme , kasutades selleks avalikult heakskiidetud mustreid . Selline arendusmeetod viib nn orgaanilise korra tekkimisele : “ Me defineerime orgaanilise korra kui korra , mis on saavutatud siis , kui on täiuslik tasakaal osade ja terviku vajaduste vahel . ” [ Alexander et al , <arv> , lk <arv> ] . Orgaanilise korra saavutamiseks tuleb rakendada järgmist printsiipi : “ Planeerimist ja ehitamist juhitakse protsessi poolt , mis võimaldab tekkida tervikul järk-järgult , lokaalsete tegevuste tulemusena . ” [ Alexander et al , <arv> , lk <arv> ] . Holistlik süsteemiarendus näeb ette , et süsteemiarendamise projekt koosneb korduvatest probleemi lahendamise tegevustest . [ Purao &amp; Storey , <arv> ] hinnangul on taaskasutamine inimeste puhul probleemide lahendamisel loomuomane käitumine . Holistlik metoodika näebki süsteemi kirjeldamise ühe meetodina taaskasutamisele suunatud funktsioonidele orienteeritud meetodit , mis kasutab standardfunktsioone kui lähtepunkti süsteemi väljatöötamisel . Sellise arendusmeetodi järgimine nõuab kogemusi ja standardsete ehitusplokkide olemasolu . Praktikas tähendab see uute süsteemimaatriksite hierarhiate loomist , kasutades sealjuures maksimaalselt ära juba olemasolevaid maatrikseid . SüSTEEMIMAATRIKS JA TEISED SüSTEEMIDE KIRJELDAMISE MEETODID Tänapäeval on de fac to modelleerimiskeel UML ( Unified Modeling Language ) [ OMG UML ] . UML-keele abil saab süsteemi kirjeldada , kasutades erinevat tüüpi diagramme . Lisaks on võimalik luua mudeliprofiile , mis kujutavad endast mingi valdkonna ( domeeni ) kirjeldamiseks loodud laiendatud semantikaga mudelielementide kogumit . Nende profiilide abil saab olemasolevaid diagrammitüüpe kasutada mis tahes probleemivaldkondade kirjeldamiseks . Autori hinnangul võiks UML-keeles tegevusdiagramm võimaldada esitada samas ulatuses informatsiooni mis süsteemimaatriks . Põhiaspektiks , millele tegevusdiagramm keskendub , on töö , mis väljendub tegevustes . Tegevusdiagramm kirjeldab tegevuste jada ning võimaldab näidata nii tingimuslikku kui paralleelset käitumist . Tegevusdiagramm on organiseeritud vastavalt rollidele . “ Ujumisrajad ” eraldavad erinevate rollide ja organisatsiooniüksuste poolt läbiviidud tegevusi . Ka süsteemimaatriksis võib eraldi kataloogina välja tuua subjektid , kes mingeid funktsioone ellu viivad , ning näidata eraldi maatriksis subjektide ja funktsioonide vahelised seosed [ Jäderlund , <arv> , <arv>.<arv> ] . Tegevusdiagrammil võib tegevused seostada objektidega , mida nad kasutavad . Samuti on süsteemimaatriksi protsessimaatriksis näidatud objektide kasutus funktsioonide poolt . Protsess võib olla liiga keerukas , et seda esitada ühel tegevusdiagrammil . Tegevusega tegevusdiagrammil võib seostada alam-tegevusdiagrammi . Süsteemimaatriksis saab sellist dekompo- sitsiooni esitada süsteemimaatriksite hierarhia abil . Tegevusdiagrammil saab kirjeldada otsustuspunkti , kus tuleb valida , milliste tegevustega jätkata . Tingimused , mis määravad valiku , saab kirja panna valvurtingimustena . Ka süsteemimaatriksis saab kirjeldada kontrollifunktsioone , millega peab olema seotud vähemalt kaks tingimust . Tingimuste täidetus määrab järgmised täidetavad funktsioonid . Tegevusdiagrammil võib kujutada paralleelselt toimuvaid tegevusi . Ka süsteemimaatriks võimaldab kirjeldada paralleelselt toimuvaid funktsioone [ Jäderlund , <arv> , <arv>.<arv> ] . Seda näidatakse kontrollimaatriksis , kui ühes veerus on mitu ühesugust numbrit . Funktsioonid , millele vastavates ridades need numbrid asuvad , täidetakse paralleelselt . Järgnevalt esitatakse tegevusdiagramm , mis esitab sama informatsiooni nagu joonisel <arv> esitatud süsteemimaatriks . Kommentaariks võib öelda , et diagrammi koostamine võttis aega rohkem kui süsteemimaatriksi koostamine , kuigi diagrammi koostamise juures ei olnud vaja enam mõelda välja lahendust , vaid see lihtsalt üles joonistada . Palju aega kulus diagrammi kujundamisele , et elemendid ei ristuks ega kattuks ja et diagrammil olevad jooned poleks väga pikad . Selle asemel , et mõelda kirjeldatavale lahendusele sisulisest küljest , kulus palju aega vormilisele küljele . Iga elemendi juures tuli mõelda , kuidas see paigutada , et kasutaja kõige paremini diagrammist aru saaks . Süsteemimaatriksi käsitlusega on sarnane nn objekti-protsessi metodoloogia ( <hyperlink> ) , mille kohaselt kirjeldatakse süsteemi holistlikult , kasutades objekti-protsessi diagramme . Ühte tüüpi diagrammil esitatakse nii objektid , protsessid kui ka objektide seisundite muutused ( vt joonis <arv> ) . Süsteemi kirjeldamiseks on loodud CASE-vahend nimega OPCAT . Selleks et võimaldada kirjeldusest paremini aru saada , näidatakse koostatud süsteemi kirjeldust paralleelselt diagrammina ja inimkeelse kirjeldusena . Inimkeelne tekst aitab diagrammi mõista ja selle õigsust kontrollida .  Joonis <arv>. Tegevusdiagrammi näide MAATRIKSI KASUTAMINE KUI MUSTER Süsteemi kirjelduse esitamine maatriksina kompaktsuse ja ülevaatlikkuse saavutamiseks on muster , mida on rakendatud ka mujal kui süsteemimaatriksis . Näiteks Oracle Designer/<arv> CASE-vahendi koosseisu kuulub utiliit Matrix Diagrammer [ Oracle Matrix Diagrammer ] . Matrix Diagrammerit on võimalik kasutada teadmusbaasi elementide ja nendevaheliste seoste loomiseks , muutmiseks ja risttabelite kaudu kontrollimiseks . Kasutajal on võimalus maatriksi kujundust muuta ja selles elemente ümber järjestada .  Joonis <arv>. Objekti- protsessi diagrammi näide Sarnaselt SystemSpecifier tarkvaraga võimaldab Matrix Diagrammer kontrollida süsteemi elementide omavahelist kooskõla . Maatriksi diagramm sisaldab kahte telge , kus kumbki tähistab erinevat elemendi tüüpi . Maatriksi lahtrid näitavad , milline on kahe elemendi vaheline seos . Näiteks võivad ühele teljele olla paigutatud olemid ja teisele teljele funktsioonid . Sellist maatriksit tuntakse CRUD-maatriksina . Oracle Designer/<arv>-s on maatriksi diagramm vaid üks abivahend süsteemi kontrollimiseks . Lisaks sellele luuakse süsteemi vaateid kirjeldavad spetsiaalsed diagrammid , nagu näiteks protsessimudelid , funktsioonide hierarhia ja olemi-suhte diagramm . Holistlikus süsteemiarenduses on süsteemimaatriks ainus vahend süsteemi kirjeldamiseks . KOKKUVõTE Antud artiklis kirjeldati holistliku süsteemiarenduse põhimõtteid . Samuti kirjeldati süsteemimaatriksit , mis on vahend süsteemiprobleemide ja nende lahenduste kirjeldamiseks . Kuigi metoodika ja maatriksi väljatöötamisest on möödunud juba mitukümmend aastat ning mõned nende aspektid vajaksid ajakohastamist ja täiendamist , ei ole nende eesmärgid ja kasutatavad ideed oma aktuaalsust kaotanud ja vääriksid kindlasti senisest rohkem tähelepanu .  Ingmar Nurmiste , TTÜ raadio- ja sidetehnika instituudi magistrant <arv>. SISSEJUHATUS Kuigi järjest enam on mobiilside kasutajale pakkuda terminalide ja tehnoloogiate arenedes teenuseid otse mobiilis , kasutakse mobiiliterminali ka edaspidi tihtipeale kui lihtsalt modemit ( süle ) arvuti Internetti ühendamiseks . Peale meilide lugemise on teine oluline kasutusvaldkond veebis surfamine . See tegevus kipub olema mobiilside jaoks optimeerimata , sest veebilehekülgede maht järjest kasvab . Mõned aastad tagasi turule toodud uus GPRS-tehnoloogia on toonud meile uudse maksustusviisi : mahu pealt maksustamine , mis soodustab veelgi mobiilsust ning üldjuhul teeb teenused atraktiivsemaks . Samas on see ka aktuaalsemaks muutnud kõikvõimalikud “ viimase miili ” kitsa andmekanali kiirendajad . Artiklis vaadatakse edastatava kasuliku info transpordiks kuluva andmemahu vähendamise ja kiirendamise viise HTTP raames . Kui vaadata kitsaribalisi ühenduskanaleid , siis tavaliselt on võimalik kanali efektiivsemaks muutmiseks kasutada madalamal tasemel toimivat komprimeerimist : ( TCP/IP ) päiste pakkimine , modemi kompressioon ( nt V.<arv> ) , nn tarkvaraline kompressioon . Mobiilse andmesidekanali puhul ei pruugi kõik need võtted kasutada olla ning mahupõhist maksustamist selline kompressioon ei mõjuta . Küll aga annab selle lisaefekti kõrgemal tasemel toimuv komprimeerimine , mida siin käsitletaksegi . <arv>. LÜHIÜLEVAADE HTTP-PROTOKOLLIST HTTP on kliendi-serveri mudelil põhinev rakendustaseme võrguprotokoll , mis on WWW üks olulisemaid osasid . Kahjuks pole tegemist kuigi efektiivse protokolliga . Et esialgsete ( HTTP/<arv>.<arv> ja <arv>.<arv> ) protokollide mõningaid nõrku kohti parandada , toodi <arv>. aastal välja edasiarendatud versioon HTTP/<arv>.<arv> [ <arv> ] . Põhilisteks parandusteks on püsiva ühenduse toetus , parem vahehoidlate toetus , parem sobivus dünaamiliselt genereeritud lehekülgedele ( nn hakitud vastused ) ning parem IP aadresside kasutamine . Hakitud vastused annavad ajavõidu dünaamiliselt genereeritud veebilehtede edastamisel , sest ülekanne algab veel enne , kui leht valmis on ( nt päringute tulemusel genereeritud lehed ) . HTTP vastustes lisatakse iga tüki ette selle tüki andmemahu suurus kuueteistkümnendiksüsteemis numbrina , viimase tüki lõppu lisatakse uuele reale “ <arv> ” . Lisaks pakub HTTP/<arv>.<arv> võimalusi ülekantava andmemahu vähendamiseks . Selleks saab kasutada gzip' ja deflate' algoritme [ <arv>,<arv> ] . Protokolli toimimine on üsna lihtsasti jälgitav . Nii HTTP-päringu kui ka vastuse päises on tavaline tekst . Lihtsustatult on päringu päises kirjas aadress ja kasutatav protokoll koos kliendi poolt toetatud andmetüüpidega . Vastuse päises on kirjas protokolli versioon , vastuse kood ( nt <arv> - OK ) ja lisaandmed ülekantava andmehulga tüübi ja selle pikkuse kohta . Näide HTTP-päringust ja vastuse päisest : HTTP-päringu näide : GET <hyperlink> Accept : image/gif , image/x-xbitmap , image/jpeg , image/pjpeg , application/vnd.ms-powerpoint , application/vnd.ms-excel , application/msword , application/x-shockwave-flash , */* Referer : <hyperlink> Accept-Language : en-us , et ; q=<arv>.<arv> , fi ; q=<arv>.<arv> Accept-Encoding : gzip , deflate User-Agent : Mozilla/<arv>.<arv> ( compatible ; MSIE <arv>.<arv> ; Windows NT <arv>.<arv> ) Host : <hyperlink> Proxy-Connection : Keep-Alive HTTP-vastuse päise näide : HTTP/<arv>.<arv> <arv> OK Connection : close Date : Thu , <arv> Aug <arv> <arv> : <arv> : <arv> GMT Server : Apache/<arv>.<arv>.<arv> ( Unix ) Debian GNU/Linux Witch/$Id : mod_witch.c , v <arv>.<arv> <arv>/<arv>/<arv> <arv> : <arv> : <arv> toma Exp $ PHP/<arv>.<arv>.<arv> X-Powered-By : PHP/<arv>.<arv>.<arv> Expires : Thu , <arv> Nov <arv> <arv> : <arv> : <arv> GMT Cache-Control : no-store , no-cache , must-revalidate , post-check=<arv> , pre-check=<arv> Pragma : no-cache Content-Type : text/html <arv>. KAHEKS JAGATUD PROXY MEETOD Kuigi ka puhtalt HTTP raames on võimalik üsna efektiivne andmeedastus , on kõige paremat efekti andvad rakendused siiski sellised , kus komprimeeriv süsteem asub nii kliendis kui serveris ( või kuskil võrgu vahepunktis ) . Nii õnnestub ka HTTP-päringuid komprimeerida . Sel juhul on vajalik andmeedastuseks kasutada ka kliendi poolel lisaprogrammi , mis võib olla keerukas või muidu ebamugav kasutada . Teisisõnu , kasutaja peab ise aktiivselt sekkuma . Sellise rakenduse üks lahendusi oleks järgmine . Tuleb luua tunnel serveri ja kliendi ( ehk võrgupoolse ja kliendipoolse proxy ) vahel , kus kõik HTTP-ühendused multipleksitakse üheks vooks ning seda voogu edastatakse jooksvalt komprimeerituna tunneli otste vahel . Erilist populaarsust sellised rakendused pole siiani saavutanud . Järgnevalt vaatame ainult puhtalt HTTP pakutavaid võimalusi . <arv>. TEISENDUSPROXY Turul on päris palju erinevaid veebiserveri tarkvaralahendusi . Kuigi paljude puhul oleks võimalik seda konfigureerida HTTP/<arv>.<arv> raames väiksemat ülekandemahtu soosivaks ( nt ühe populaarsema , Apache puhul on olemas vastav lisa-programmiosa ) , siis tundub , et neid võimalusi väga aktiivselt ei ei kasuta . Ühe positiivse näitena saab siiski tuua ühe suurema otsingumootori Google , mis saadab HTTP-vastused välja komprimeeritult , kui brauser kasutab HTTP/<arv>.<arv> protokolli ja toetab komprimeerimist . Teine selline näide on Postimehe võrguväljaanne . Praktiliselt kõik tänapäevased ja ka natuke vanemad enamkasutatud veebibrauserid toetavad komprimeeritud HTTP-ülekannet . Tuleb ainult tähele panna , et brauser oleks konfigureeritud HTTP/<arv>.<arv> kasutama . Näiteks MS Internet Exploreri vaikimisi seadistuses ei kasuta ta HTTP/<arv>.<arv> protokolli , kui ta on konfigureeritud proxyt kasutama . Kui originaalserver komprimeeritud ülekannet ei toeta , jääb veel võimalus see ära teha ühenduse vahepealses proxys . Selline teisendusproxy on näiteks EMT poolt pakutav Veebifiltri teenus [ <arv> ] . Teisendusproxy peab analüüsima esmalt HTTP-päringute ja HTTP-vastuste päiseid ja leides , et ülekantav andmemaht on komprimeeritav , pakib selle kokku HTTP standardseid võimalusi kasutades . Kliendini jõuavad täpselt samad andmed , ainult et väiksema ülekandemahuga edastatuna . Mõne lahenduse puhul ( nagu mainitud Veebifilter ) töödeldakse ka ülekantavaid pilte , tehes need nt mustvalgeks või vähendades resolutsiooni , mis vähendab ülekandemahtu veel tunduvalt , kuid miinuspoolena pole sel juhul ülekantud info originaaliga muidugi enam identne . Et kasutatakse HTTP/<arv>.<arv> standardseid võimalusi , ei pea klient omalt poolt praktiliselt midagi konfigureerima . Vaatame neid etappe lähemalt konkreetse teisendusproxy näite varal . KatsetusProxy HTTP komprimeerimise efektiivsuse ( eelkõige säästetava ülekantava andmemahu ) hindamiseks koostasin programmi KatsetusProxy , mis käitub ülalkirjeldatud teisendusproxyna . Pakkimisfunktsioon töötab puhtalt HTTP raames . Selleks uuritakse iga saabunud paketi päist ja komprimeerimispotentsiaaliga vastused pakitakse . Borland Delphis koostatud programm põhineb Primoz Gabrijelcici koostatud proxy komponendil ( vabavara ) [ <arv> ] , millele on lisatud komprimeerimise osa . Komprimeerimine toimub zlib paketi ( vabavara ) [ <arv> ] poolt pakutavate komponentide abil , voo jooksva komprimeerimise lahenduse jaoks on kasutatud algallikana üht komponenti Delphi vabakasutusega komponentide paketist LVK [ <arv> ] . Järgnevalt on toodud antud teisendusproxy komprimeerimisosa toimimispõhimõtte lühikirjeldus liiklussuunal veebiserverist brauserisse . Esiteks uuritakse , kas HTTP-vastuses on pakitavaid andmeid . Antud juhul peetakse pakitavaks kõike tekstikujulist ( HTML , plain text , ... , javascript ) , Selleks otsitakse päisest rea lõiku Content-Type : text/' või Content-Type : application/x-javascript' . Selle leidnuna tegeletakse selle paketiga edasi , vastasel juhul edastatakse see muutmata kujul kliendile . Järgmise sammuna tuleb veenduda , et ülekandel ei kasutata juba pakkimist . Selleks otsitakse päisest ridu transfer-encoding : deflate' , transfer-encoding : gzip' , content-encoding : deflate' või content-encoding : gzip' . Kui neid ei leita , siis saab paketiga edasi tegeleda . Edasi muudetakse vajadusel paketis HTTP versiooni tähistust . Et HTTP/<arv>.<arv> ei toeta komprimeerimist , siis tuleb selle versiooniga serveri poolt koostatud paketid ümber nimetada HTTP/<arv>.<arv> pakettideks . Järgmine samm on uurida , kas server kasutab hakitud edastamist . Päisest otsitakse rida Transfer-Encoding : chunked' . Kui see leidub , tuleb paketti teistmoodi töödelda , võrreldes tavalise paketiga . Samuti tuleb vahet teha juhtudel , kas info maht on päises kirjas või ei ( otsitakse rida Content-Length : ) . Lõpuks peab ümbertehtud päis sisaldama ridu : Transfer-Encoding : chunked Content-Encoding : deflate . Ehk lihtsuse huvides on kõik töödeldud paketid teisendusproxyt läbides muudetud hakitud edastamist kasutavaks ja komprimeerimine toimub deflate algoritmiga . Edasi leitakse , kas HTTP-le korraga üle antud andmepakett sisaldab kogu HTTP-vastust või ainult osa sellest . Kui tegu on ainult osaga , pannakse see pooleli olevate ülekannete mälulisti kirja . Mälulistis eristatakse erinevaid vastuseid socketite järgi . Seejärel komprimeeritakse antud pakett ja saadetakse edasi brausrisse . Edaspidi toimubki sissetulevate pakettide puhul kas uute vastuste päiste analüüs ja vajadusel komprimeerimine või siis vastavalt mälulistile vanade vastuste komprimeerimise jätkamine ja edastamine . KatsetusProxyst läbiminevate andmete mahu hindamiseks on võimalik loendada nii enne teisendamist kui selle järgselt edastatud andmeid , lisaks saab jälgida kogu HTTP liiklust . <arv>. ANDMEMAHU VÄHENDAMISE KATSED Uurimaks , millist võitu annab teisendusproxy kasutamine , sai tehtud mitmeid erinevaid katseid . Brauser konfigureeriti kasutama samas arvutis asuvat KatsetusProxyt ning KatsetusProxy oli ühendatud Internetiga . Nagu mainitud , peab KatsetusProxy arvet temast läbi liikuva andmemahu kohta , nii algse kui teisendatud andmevoo jaoks . Et uurida ainult teisendusest saadavat efekti , tühjendati brausri vahehoidla iga katse järel . Järgnevalt vaatame iga katse tulemust lähemalt . Google'i otsing ja Postimehe avaleht erinevate protokollidega Uurimaks , millist efekti annab veebiserveri poolt rakendatud komprimeerimine , tehti sama Google otsing kord HTTP/<arv>.<arv> ja kord HTTP/<arv>.<arv> kasutades , sama tehti Postimehe avalehega . Ülekandemahtude ülevaade on toodud järgmises tabelis .  Katse Ülekantud maht ( B ) Vahe ( % ) Vahe ( B ) Google HTTP/<arv>.<arv> <arv> <arv> Google HTTP/<arv>.<arv> <arv> <arv> - <arv>,<arv> % - <arv> <arv> Postimees HTTP/<arv>.<arv> <arv> <arv> Postimees HTTP/<arv>.<arv> <arv> <arv> - <arv>,<arv> % - <arv> <arv> Sama tabel graafikuna  Joonis <arv>. HTTP/<arv>.<arv> ja HTTP/<arv>.<arv> ülekandemahu erinevus HTTP/<arv>.<arv> kasutades vähenes ülekandemaht rohkem kui kolmandiku võrra . HTTP/<arv>.<arv> protokolliga ülekantud <arv> baidi suhtes läks HTTP/<arv>.<arv> kasutades vaja <arv> baiti Google , i ja <arv> baiti Postimehe jaoks . Postimehe puhul vähenes maht suhteliselt vähem , mida saab seletada näiteks suurema hulga piltidega lehekülje sisus . Olgu veel mainitud , et selle katse ülekandemahtudes on ainsana sees ka HTTP-päringute andmemaht , kõikidel järgnevatel katsetel on esitatud ainult HTTP-vastuste andmemaht . Delfi avaleht Ajalehtede ja portaalide sirvimise näitena kasutasin esimesena portaali Delfi ( ) avalehe mahalaadimist . Teise katsena tegin sama testi ilma pilte laadimata .  Katse Ülekantud maht ( B ) Vahe ( % ) Vahe ( B ) Originaal piltidega <arv> <arv> Läbi proxy piltidega <arv> <arv> - <arv>,<arv> % - <arv> <arv> Originaal piltideta <arv> <arv> Läbi proxy piltideta <arv> <arv> - <arv>,<arv> - <arv> <arv> Koos piltidega ülekande puhul vähenes maht rohkem kui veerandi võrra , piltideta ülekande puhul ligi <arv> protsenti . Graafikuna väljendades :  Joonis <arv>. Portaali Delfi esilehe ülekandemaht Ilma KatsetusProxyta üle kantud <arv> baidi suhtes läks KatsetusProxyt kasutades vaja <arv> baiti piltidega ja <arv> baiti piltideta ülekande jaoks . Ajalehed Eesti Päevaleht ja Postimees Järgmisena vaatasin ajalehe Postimees avalehte .  Katse Ülekantud maht ( B ) Vahe ( % ) Vahe ( B ) Originaal piltidega <arv> <arv> Läbi proxy piltidega <arv> <arv> - <arv>,<arv> % - <arv> Originaal piltideta <arv> <arv> Läbi proxy piltideta <arv> <arv> - <arv>,<arv> - <arv> Siin on ülekantud andmemahtude vahe , nagu ka absoluutne andmemaht , üsna väike . Nagu eespool mainitud , kasutab Postimehe veebiserver ise komprimeeritud edastamist . Väike võit teisendusproxy kasutamisel tuleneb JavaScriptide ja text/css' andmete komprimeerimisest , mida veebiserver ise ei teinud . Samad andmed graafiku kujul :  Joonis <arv>. <hyperlink> esilehe ülekandemahu katse Ilma KatsetusProxyta ülekantud <arv> baidi suhtes läks KatsetusProxyt kasutades vaja <arv> baiti piltidega ja <arv> baiti piltideta ülekande jaoks . Teise ajalehe veebiversiooni katseks oli Eesti Päevalehe avalehe laadimine .  Katse Ülekantud maht ( B ) Vahe ( % ) Vahe ( B ) Originaal piltidega <arv> <arv> Läbi proxy piltidega <arv> <arv> - <arv>.<arv> % - <arv> <arv> Originaal piltideta <arv> <arv> Läbi proxy piltideta <arv> <arv> - <arv>,<arv> - <arv> <arv> Tulemus on sarnane Delfi katse omaga . Võrreldes Postimehe mahtudega on ülekandemahud tunduvalt suuremad , kuid piltideta katse puhul läbi teisendusproxy saab sarnase tulemuse . Samad andmed graafiku kujul :  Joonis <arv>. <hyperlink> avalehe ülekandemahu katse Siin ilma KatsetusProxyta ülekantud <arv> baidi suhtes läks KatsetusProxyt kasutades vaja <arv> baiti piltidega ja <arv> baiti piltideta ülekande jaoks . Põhiliselt teksti ja tabeleid sisaldavad lehed HTML-vormingus tabelid on väga suure komprimeerimispotentsiaaliga , sest korduvaid elemente on väga palju . Selle hindamiseks on kasutatud ühe spordiürituse - Haanja maratoni [ <arv> ] finiðiprotokolli .  Katse Ülekantud maht ( B ) Vahe ( % ) Vahe ( B ) Originaal <arv> <arv> Läbi proxy <arv> <arv> - <arv>,<arv> % - <arv> <arv> On näha , et selliste andmete korral saavutatakse märkimisväärne võit ülekandemahu vähendamisel . Samad andmed graafiku kujul :  Joonis <arv>. Suurt tabelit ( finisiprotokolli ) sisaldava lehe ülekandemahu katse Siin ilma KatsetusProxyta ülekantud <arv> baidi suhtes läks KatsetusProxyt kasutades vaja <arv> baiti . Tegin veel teise katse tabelit sisaldava lehe jaoks , milleks oli börsi päevastatistika lehekülg ( ) . Lisaks keerulisemale ( aga väiksemale ) tabelile on seal ka mõned pildid ja hulk linke .  Katse Ülekantud maht ( B ) Vahe ( % ) Vahe ( B ) Originaal <arv> <arv> Läbi teisendusproxy <arv> <arv> - <arv>,<arv> % - <arv> <arv> Need andmed graafiku kujul :  Joonis <arv>. Börsi tehingustatistika lehe ülekandemahu katse Siin ilma KatsetusProxyta ülekantud <arv> baidi suhtes läks KatsetusProxyt kasutades vaja <arv> baiti . Puhtalt teksti sisaldava lehe allalaadimise katseks kasutasin umbes <arv> kB mahuga lehte Rasi serverist [ <arv> ] . Ülekandemahu vähenemine oli oodatud suurusjärgus :  Katse Ülekantud maht ( B ) Vahe ( % ) Vahe ( B ) Originaal <arv> <arv> Läbi proxy <arv> <arv> - <arv>,<arv> % - <arv> <arv> Siin ilma KatsetusProxyta ülekantud <arv> baidi suhtes läks KatsetusProxyt kasutades vaja <arv> baiti .  Joonis <arv>. Ainult HTML-teksti sisaldava lehe ülekandemahu katse <arv>. KOKKUVÕTE Katsete tulemused näitasid , et antud teisendusproxy puhul õnnestub ülekandemahtu vähendada umbes <arv>-<arv>% piltidega pikitud lehtede puhul kuni ligemale <arv>% põhiliselt teksti/tabeleid sisaldavate lehekülgede puhul . Konkreetsete katsete puhul läks ilma KatsetusProxyta ülekantud <arv> baidi suhtes KatsetusProxyt kasutades piltidega saidi ülekandeks vaja u <arv> baiti , piltideta saidi puhul u <arv> baiti ja tabelit sisaldava saidi puhul <arv> baiti . On hästi näha , et selline HTTP peal ülekantavate andmete komprimeerimine annab selge kokkuhoiu ülekandemahu pealt . Jääb vaid loota , et HTTP-andmete komprimeeritud kuhul edastamist kasutatavate veebiserverite hulk kasvab . Seniks oleks võrguoperaatoritel teisendusproxy teenuste pakkumine hea lahendus , kusjuures pakkuda võiks nii pilte teisendavat varianti kui originaalandmeid täielikult säilitavat varianti . Kuna katsed tehti lairibalises keskkonnas , siis ajavõidu uurimine polnud otstarbekas . Samuti tuleb märkida , et siin ei ole arvestatud vahehoidla mõju ülekandemahtudele , mis võiks olla ka edasise uurimise teemaks .  Erika Matsak , Tallinna Ülikooli loodusteaduste osakonna teadur <arv>. VEIDI AJALOOST <arv>-ndate aastate lõpus käivitati tolleaegses ENSV TA Küberneetika Instituudis , Tartu Riiklikus Ülikoolis ja Tallinna Polütehnilises Instituudis programm “ Intellektuaalsed süsteemid ” , mis pidi plaanikohaselt ühendama ühtsesse tervikusse mitmeid valdkondi matemaatilisest loogikast , programmeerimise ja arvutisüsteemide teooriast , keeleteadusest ja muust . Asjakohane ühisuuringute kava valmis <arv>. aastal ja selles oli ühe osana esile toodud üsna ulatuslik uurimus loogiliste konstruktsioonide olemasolust ja kujunemismehhanismidest inimintellektis ning nende esiletoomise vahenditest . Sealhulgas kavandati ka uurimust laste kõnes ja lastele lugemiseks-kuulamiseks mõeldud tekstides sisalduvatest loogilistest konstruktsioonidest . Omamoodi eeltööna oli loogiliste konstruktsioonide väljaeraldamise vallas jõutud mitmeid aastaid kestnud pingutuste tulemusena ajakitsendustega interaktiivsete protsessisüsteemide kirjeldamiseks vajalike nn nõrga <arv>-järku predikaatarvutuse keeleliste vahendite ja deduktsiooniaparaadi formaliseerimiseni [ Lorents , Mõtus , Tekko <arv> ] . Nimetatud vahendid “ saadi kätte ” just sel teel , et kirjutati üles ning analüüsiti seda , mida kõnelesid neist asjadest ( s.t ajakitsendustega interaktiivsete protsesside süsteemidest ) vaadeldaval alal töötavad insenerid ja teadurid . Kahjuks soikus ülalkirjeldatud projekt <arv>-ndate alguses seoses üleminekuaja segaduste , raskuste ja mitmete inimeste lahkumisega . Loogiliste konstruktsioonide loomuliku keele tekstidest väljaeraldamisalased uuringud aga “ hingitsesid ” tasapisi siiski edasi . <arv>. aastal kaitses Tallinna Tehnikaülikoolis tollases elektronarvutite kateedris Dmitri Baranov oma lõputööd , milles käsitleti loomuliku keele tekstides esinevaid loogilisi konstruktsioone . Loomuliku keele rollis oli seejuures vene keel . Kaks aastat hiljem - aastal <arv> - jätkas ülalnimetatud uuringuid Tallinna Pedagoogikaülikoolis Diana Lorents , kelle lõputöö teemaks oli “ Loogilised konstruktsioonid eesti keele tekstides ” [ Lorents , D. <arv> ] . Viimati nimetatud töö tõi esile seosed sõnaliikide ja loogiliste rollide vahel ning selgitas välja loogiliste operaatorite ja kvantorite eestikeelsed vasted . Aastal <arv> ilmus trükist raamat “ Keel ja loogika ” [ Lorents , P. <arv> ] , kus kirjeldati nn tekstide transformeerimise protseduuri , mis on mõeldud loomuliku keele tekstides sisalduvate loogiliste konstruktsioonide kättesaamiseks . <arv>. LOOGIKA JA LOOMULIKU KEELE TEKSTID Selleks et uurida ja rakendada tehnilistes süsteemides inimintellektile iseloomulikke loogilisi konstruktsioone , tuleb kõigepealt leida vahendid , mille abil eelnimetatud konstruktsioonid inimestelt “ kätte saada ” . Üheks ( kui mitte ainsaks ) võimaluseks on seejuures lähtumine nn loomulikus keeles esitatud tekstidest . Valdkondade kirjeldused ning asjakohased arutluskäigud on see ala , kus nii ehk teisiti ilmutavad end inimese valduses olevad loogilised vahendid : ühe või teise loogika keel , valemid ja deduktsiooniaparaat . Siinkohal rõhutame , et sõnade ühe või teise loogika mõte seisneb selles , et pole olemas ühte ja ainukest loogikat . Vastandina üldlevinud arusaamale pole loogikaks mitte see ainus ja õige , mida peaasjalikult seostatakse veenvat esinemist toetava Aristotelese süllogistikaga , vaid teatavad kirjeldus- ja tuletusvahendeid hõlmavad süsteemid ehk loogikad ( näiteks nn klassikaline loogika , intuitsionistlik loogika , modaalne loogika jt ) . Nagu eespool öeldud , hõlmab mingi loogika teatavaid keelelisi vahendeid : fikseeritud sümbolite kogum ehk alfabeet , just selle alfabeedi sümbolitest moodustatud väljendite kogum ehk keel , korrakohasel viisil sooritatavaid tegevusi , tehteid vms esitavad väljendid - eeskirjad ehk termid , individuaalsete objektide ning termide omadusi ja omavahelisi seoseid esitavad väljendid - väited ehk valemid . Vaadeldava loogika tuletusvahendid sisaldavad juba põhjendatuks oletavatest valemitest ( väidetest ) uute põhjendatuks loetavate väidete saamiseks vajalikke reegleid - tuletusreegleid , aprioorselt põhjendatuid ehk põhjendust mittevajavaid valemeid ( väiteid ) - aksioome . Lisaks eelnimetatutele asjadele hõlmab loogika veel n-ö semantilisi vahendeid , millest olulisimad on väidete hindamiseks vajalike hinnangute ehk tõeväärtuste korrastatud kogum ehk tõeväärtuste skaala , väljenditele tähenduse , sh hinnangute omistamise vahendid ehk interpretatsioonid . Otsene või kaudne seotus tõeväärtustega on üheks olulisimaks tunnuseks , mille alusel saab loomuliku keele tekstidest välja eraldada need osad , mis esitavad või peegeldavad loogilisi konstruktsioone . <arv>. TEKSTIDE TRANSFORMEERIMISE PROTSEDUUR Aastal <arv> ilmunud raamatus “ Keel ja loogika ” esitas P. Lorents spetsiaalse protseduuri , millele toetudes on võimalik loomuliku keele tekstidest välja eraldada loogilisi konstruktsioone . Nimetatud protseduur hõlmab seitset liiki samme ehk etappe , mille rakendamisel uuritav lähtetekst teiseneb ehk transformeerub loogilisteks konstruktsioonideks ( eelkõige termideks ja valemiteks ) . Nendeks etappideks on töödeldava teksti osade ümberpaigutamine , täiendamine ( ehk uute osade lisamine ) , taandamine ( ehk olemasolevate osade eemaldamine ) , asendamine ( ehk mõne olemasoleva osa asendamine mingi uue tekstiga ) , sümbolite väljaeraldamine ( ehk nende tekstiosade väljatoomine , millel on mõne loogika alfabeedi sümboli roll ) , sümbolite liigitamine ( sümbolitena väljaeraldatud tekstiosade rolli täpsustamine - näiteks kas on tegu mõnd objekti tähistava sümboliga , objektide omadust või objektidevahelist seost või hoopis loogilist operatsiooni tähistava sümboliga vms ) , sümbolite positsioneerimine ( sümbolite paigutamine sinna , kus nad loogilistes konstruktsioonides peaksid korrakohaselt paiknema ) . Näited : “ Oleme koos . ” → Täiendamine → “ Meie oleme koos ” ? P <arv> ( q <arv> ) , → , kus P <arv> - olema koos , q <arv> - meie . “ Kass sööb küll kala ” → Taandamine ? “ Kass sööb kala ” →P<arv> ( q <arv> , q <arv> ) , kus P <arv> - söömine , q <arv> - kass , q <arv> - kala . “ Lõpuks ometi on kiisupoeg leidnud sõbra ” → Täiendamine → “ Enne kiisupojal ei olnud sõpra ja lõpuks ometi on kiisupoeg leidnud sõbra ” → Asendamine → “ Enne kiisupojal ei olnud sõpra ja nüüd on kiisupoeg leidnud sõbra ” → Ümberpaigutamine → “ Enne kiisupojal ei olnud sõpra ja nüüd kiisupoeg on leidnud sõbra ” → Asendamine → “ Enne kiisupojal ei olnud sõpra ja nüüd kiisupojal on olemas sõber ” →Taandamine → “ Enne kiisupojal ei olnud sõpra ja nüüd kiisupojal on sõber ” → Ø A <arv> ( x <arv> , x <arv> , t <arv> ) &amp; A <arv> ( x <arv> , x <arv> , t <arv> ) , kus A <arv> - olema , x <arv> - kiisupoeg , x <arv> - sõber , t <arv> - esimesel ajahetkel ( enne ) , t<arv>- praegusel ajahetkel ( nüüd ) . Iga eelkirjeldatud etapi teostamisel aga nõutakse , et vastava lähteteksti ja etapi lõpul saadud teksti tähendus oleks sama . Ja kas see ikka tõesti nii on , jääb transformeerija otsustada ja vastutada . Siit järeldub , et nimetatud transformeerimise protseduuri pole põhimõtteliselt võimalik n-ö lõpuni automatiseerida , mis aga sugugi ei välista vastava dialoogsüsteemi võimalikkust . “ Dialoogi vajalikkus ” tuleneb lisaks eelöeldule ka teatavatest algoritmiteoreetilistest kaalutlustest , mida siinkohal paari sõnaga tutvustame . Nimelt on loomuliku keele tekstid sümbolitest koosnevad moodustised ( sõnad , väljendid vms ) . Lisades loomuliku keele sümbolitele matemaatilise loogika sümbolid , me säärast olukorda ei muuda . Ikka on meil tegemist teatavas alfabeedis kirja pandud väljenditega . Tekstide transformeerimise samme võib aga käsitleda kui seda , mis toimub mingis asendussüsteemis , näiteks mõnes nn Thue süsteemis ( vt nt [ Ìàëüöåâ À . <arv> ] ) . Seejuures on aga teada , et isegi “ väga tagasihoidliku ” asenduste süsteemide korral pole nn sõnade samaväärsuse probleem algoritmiliselt lahendatav . Järelikult on vaja “ oraaklit ” ehk antud juhul programmiga dialoogrežiimis töötavat kasutajat ( vt nt [ Rogers H. <arv> ] , [ Óñïåíñêèé Â . , Ñåìåíîâ À . <arv> ] ) . Ühte niisugust dialoogsüsteemi , milles piirdutakse loogiliste valemite tasemega ( s.t ei käsitleta loogilisi tuletusreegleid ) , järgnevalt kirjeldamegi . Seejuures kitsendame vaadeldavat valdkonda ja vaatleme vaid sääraseid loogilisi konstruktsioone , mis on iseloomulikud predikaatarvutusele . <arv>. EESTIKEELSETE TEKSTIDE TRANSFORMEERIMISE DIALOOGSÜSTEEMI MÕNED ISEÄRASUSED Käesolevas kirjutises vaadeldakse ühest küljest eestikeelseid tekste ning loogiliste rollidega morfoloogilisi seoseid . Teisest küljest jõutakse sellise tarkvaralise rakenduseni , mis aitab välja eraldada tekstides sisalduvaid loogilisi konstruktsioone ja moodustada neist lähtudes loogika valemeid . Seejuures , nagu eespool juba märkisime , ei käsitleta antud juhul neid loogilisi konstruktsioone , mis on seotud väidete põhjendamisega . Seetõttu ei saa vaadeldava süsteemi abil käsitleda edaspidi ei tuletussamme , tuletusreegleid ega tuletusi ehk tõestusi , vaid piirdutakse n-ö valemite tasemega . Järgnevalt kirjeldatava dialoogsüsteemi teiseks eripäraks on selle n-ö õpetatavus , mille aluseks on kasutajapoolsed kinnitused süsteemi “ ettepanekutele ” ühe või teise sammu teostamise osas ning kasutajapoolsed vastused süsteemipoolsetele küsimustele . Nimetatute asjade realiseerimiseks on programmeeritud vastavad iseõppivad moodulid . Süsteemi kasutamise efektiivsus tõuseb koos läbitöötatud lausete tüüpide hulgaga . Eelnevast aga tuleneb , et kõnealust dialoogsüsteemi saavad kasutada inimesed , kes ise on tuttavad teksti transformeerimisega formaalsesse keelde . Selline nõudmine lähtub tõsiasjast , et kasutaja peab kinnitama arvutipoolseid samme ja valikuid , kuna vastasel juhul on olemas risk jõuda teksti mõttega mittesobiva valemi juurde . Vaadeldava dialoogsüsteemi loomine sai võimalikuks tänu firma FILOSOFT poolt väljatöötatud tarkvarale “ Eesti keele HTMLi morfanalüsaator ” ja “ Eesti keele süntesaator ” , mis asuvad aadressil <hyperlink> ja võimaldavad saada morfoloogilisi tähiseid sõnade kohta ning vastupidi - algvormist moodustada sõnu vajalikus morfoloogilises vormis . Siinkohal märgime , et põhimõtteliselt on eelnimetatud dialoogsüsteemi algoritmi võimalik rakendada ka teistes keeltes , kui on olemas vastava keele lingvistilised programmid , mis võimaldavad teha automaatseid päringuid ja saada tagasisidet morfoloogiliste liikide kohta , ning programmid , mis võimaldavad sõnade sünteesi . Lisaks sellele oleks algoritmi realiseerimiseks vaja läbi viia uuringuid , mis näitaksid , kuidas konkreetses keeles on seotud loogilised rollid ja morfoloogilised liigid . Lause transformeerimisel on vaja määrata loogilisi rolle . Vaadeldavas dialoogsüsteemis on võetud kasutusele järgmised tekstide rollid , milles võib “ esineda ” üks või teine tekstiosa , mis ise on samuti tekst , erijuhul mingi sümbol ( näiteks võib tekstiosa “ kui ... siis ... ” olla loogilise operaatori rollis ) : predikaadid , indiviidid , loogilised operaatorid ja kvantorid , modaalssuse operaatorid , aja sorti sümbolid . Teksti transformeerimisel on oluline , et lause esialgne tähendus ei muutuks . Seejuures ei ole tähtis transformeerimise etappide järjekord ega ole määratletud etappide kasutamise arv . Samuti ei eristata seda , milline etapp on teistest olulisem või milline vähem oluline . Inimestel , kes on saanud vastava väljaõppe lausete formaliseerimiseks ja kes suudavad “ käsitsi ” transformeerida olemasolevaid tekste , võivad tekkida järgmised probleemid : lausete transformeerimine hakkab nõudma liiga palju aega , transformeerimise käigus kasutatakse liialt “ omaloomingut ” ( transformeerimissammude tulemusena võib saada “ liiga erinevaid ” valemeid ) . Dialoogsüsteemi kasutamine muudab protsessi ki iremaks ( sest kasutaja roll seisneb eelkõige sammude kinnitamises ) . Keerulisemate lausete korral õpetatakse programmi ja edaspidi saab ikka rohkem kasutada automaatseid , “ šabloonseid ” lahendusi . Sellega saab oluliselt vähendada eespool nimetatud omaloomingut . <arv>. LAUSETE TRANSFORMEERIMINE DIALOOGSÜSTEEMI ABIL Kõnealuses dialoogsüsteemis on lausete transformeerimiseks kaks reþiimi . Esimene re þii m on programmi nn õpetamine . Kasutaja transformeerib samm-sammult lause , kirjutades vahevariandid teksti väljadesse . Iga lause läbib morfoloogilise analüüsi , mille tulemuseks on salvestatud morfoloogiliste tähiste skeem . Iga lause korral jäetakse meelde sõnade järjekorra muutmine ja uute sõnade lisamisel jäetakse meelde tähiste morfoloogiline kuju ( järjekorra skeem ) . Näide . Õpetame programmile transformeerimist lausega “ Mina mängin ilusa nukuga ” . Õppeprotsessi tulemusena tekib morfoloogiliste tähiste skeem : = _P_+sg+#n# _V_+#n# _A_+sg+g# _S_+sg+kom# = _P_+sg+#n# _V_+#n# _S_+sg+kom# &amp; _S_+sg+#n# _V_+#b# ! _A_+sg+#n# = ( Morfoloogilised tähised on seletatud tabelis <arv> ) ja järjekorra skeem : <arv> <arv> <arv> <arv> = <arv> <arv> <arv> uus &amp; <arv> uus_V_+#b# ! <arv> = Alglauses olid sõnad nummerdatud numbritega <arv> ( Mina ) , <arv> ( mängin ) , <arv> ( ilusa ) , <arv> ( nukuga ) . Transformeeritud lauses on sõnade asukoht muutunud , näiteks kolmandal positsioonil olev sõna peab olema numbriga <arv> ( nukuga ) , mitte <arv> ( ilusa ) . Lisaks on tekkinud kaks uut sõna uus &amp; ( ja ) ning uus_V_+#b# ! ( on ) . Sõnade võrdlemine käib algsõnade abil järjekorra skeemi moodustamise teel ning pole oluline , mis vorm oli sõnal esimeses lauses ja milline on see transformeeritud lauses . Teine re þii m on on lausete automaatne transformeerimine vastavalt eelnevalt leitud morfoloogilisele skeemile . Reþiim tugineb sellele , et kui lausetel on võrdsed morfoloogilised skeemid , siis saame tulemuseks võrdsed loogilised konstruktsioonid formaalsel kujul . Näited . “ Mina mängin ilusa nukuga ” → “ Mina mängin nukuga ja nukk on ilus ” → P <arv> ( q <arv> , x <arv> ) &amp; P <arv> ( x <arv> ) . “ Mina sõidan uue autoga ” → “ Mina sõidan autoga ja auto on uus ” → P <arv> ( q <arv> , x <arv> ) &amp; P <arv> ( x <arv> ) . “ Minu kodus on ka akvaarium , kus ujuvad kalad ” → “ Kodu on minu ja kodus on akvaarium ja akvaariumis ujuvad kalad ” → P <arv> ( x <arv> , ) &amp; P <arv> ( x <arv> , x <arv> ) &amp; P <arv> ( x <arv> , q <arv> ) . “ Minu maakonnas on ka talu , kus elavad jaanalinnud ” → “ Maakond on minu ja maakonnas on talu ja talus elavad jaanalinnud ” → P <arv> ( x <arv> , ) &amp; P <arv> ( x <arv> , x <arv> ) &amp; P <arv> ( x <arv> , q <arv> ) . Antud juhul automaatne transformeerimine ei arvesta semiootilisi probleeme ja on lahendatud järgmiselt . Kui arvutit õpetati lausega “ Mina mängin ilusa nukuga ” , siis uue lause sisestamisel “ Mina jalutan vallatu koeraga ” , tuvastab arvuti morfoloogilises skeemis esimese osa kattumise . Morfoloogilisest analüüsist on saadud ka “ algsõnad ” : mina jaluta vallatu koer . Nüüd on teada , millises järjekorras peavad olema need sõnad transformeeritud lauses : mina jaluta koer uus &amp; koer uus_V_+#b# ! vallatu . Avastades esimeses uues sõnas loogilise operaatori &amp; , asendatakse see vastava sõnaga “ ja ” ning kuna “ ! ” on programmis seotud sõnaga olema , siis on võimalik väljastada õige tähendus . Pärast seda vaadatakse , mis morfoloogilistes vormides peavad olema sõnad uues lauses ja saadetakse iga sõna keele süntesaatorisse , mis tagastab selle õiges vormis . Nii saadaksegi transformeeritud lause “ Mina jalutan koeraga ja koer on vallatu ” . Asendades sõnu formaalses keeles olevate sümbolite abil , on võimalik saada valem , mis on nn preformaalsel kujul . Ei saa välistada , et leidub lauseid , kus selline automaatne transformeerimine annab ebakorrektseid tulemusi . Väiksemate vigade parandamiseks on kõik sõnad väljastatud tekstiväljadesse , kus on võimalik teha parandusi . On võimaldatud ka üleminek esimesele ( mitteautomaatsele ) reþiimile . Tabel <arv> Morfoloogiliste tähiste tähendused  Tähendus _P_+sg+#n# asesõna ( pronoomen ) , nt see ainsus : nominatiiv nimetav _V_+#n# tegusõna ( verb ) , nt lugema kindel kõneviis olevik <arv>. isik ainsus aktiiv jaatav kõne Näiteks : loen _A_+sg+g# omadussõna - algvõrre ( adjektiiv - positiiv ) , nii käänduvad kui käändumatud , nt kallis või eht ainsus : genitiiv omastav _S_+sg+kom# nimisõna ( substantiiv ) , nt asi ainsus : komitatiiv kaasaütlev _S_+sg+#n# nimisõna ( substantiiv ) , nt asi ainsus : nominatiiv nimetav _V_+#b# ! tegusõna ( verb ) , nt lugema kindel kõneviis olevik <arv>. isik ainsus aktiiv jaatav kõne tegusõna olema vastav vorm _A_+sg+#n# om adussõna - algvõrre ( adjektiiv - positiiv ) , nii käänduvad kui käändumatud , nt kallis või eht ainsus : nominatiiv nimetav <arv>. ALGORITMI KIRJELDUS index.html Kõigepealt on vaja sisestada oma kood . Koodide kasutamine võimaldab ühelt poolt piiritleda programmi kasutamist antud grupiga , teiselt poolt annab kõikidele grupiliikmetele võimaluse programmi paralleelselt kasutada .  Joonis <arv>. Programmi üldine plokkskeem  Joonis <arv>. Esileht index.pl Script on mõeldud teksti sisestamiseks . Laused peavad olema grammatiliselt õigesti kirjutatud ja lause lõpus peab olema punkt . Graafilisele keskkonnale on lisatud nupud teksti edastamiseks järgmisele scriptile ja teksti tühjendamiseks . e<arv>.pl Script sisaldab järgmisi mooduleid : Vigade kontroll . Teksti korrastamine , kui olid kasutusel üleliigsed tühikud sõnade vahel . Eestikeelsete “ täpitähtede ” ümberkodeerimine . Teksti jagamine lauseteks ja sõnadeks . Tõeväärtuste olemasolu tuvastamine . Kontrollitakse , kas lausel on tõeväärtus või ei ole . Kui lause sisaldab tegusõna ja kui see tegusõna ei ole käskivas vormis , siis süsteem pakub , et lause omab tõeväärtust . Kasutaja peab kinnitama arvuti poolt pakutava vastuse . Graafilisele keskkonnale on lisatud nupud teksti edastamiseks järgmisele scriptile ja tagasipöördumiseks teksti sisestamisele . e<arv>.pl Esimese või hiljem valitud lause analüüs . Script sisaldab järgmisi mooduleid : Operaatorite ja kvantorite otsing . Programm otsib loogilisi operaatoreid ning kvantoreid , modaalsuse operaatoreid ja palub kasutajal kinnitada õigsust . Selleks on valmistatud failid , kus iga variandi jaoks on antud sünonüümid . Morfoloogiline analüüs . Automaatne pöördumine morfoloogilisse andmebaasi , mis asub aadressil <hyperlink> , ja morfoloogilise tagasiside saamine . Programmi moodul dešifreerib tähised sõnaliikideks ja pakub kasutajale võimalikud õiged variandid . Morfoloogilise skeemi moodustamine . Moodul , mis koostab lause morfoloogilise skeemi tervikuna pärast kasutaja kinnitamist .  Joonis <arv>. Morfoloogiline analüüs Graafilises keskkonnas saab kasutaja jälgida enda tehtud valikuid , moodustades lause morfoloogilise skeemi . On lisatud ka nupud teksti edastamiseks järgmisele scriptile ja tagasipöördumiseks teksti sisestamise juurde . e<arv>.pl Script töötleb saadud morfoloogilise lause skeemi . Scriptis on järgmised moodulid : Lause osad . Lause osade eraldamine vastavalt konjunktsiooni , disjunktsiooni või implikatsiooni olemasolule . Indiviidi tuvastamise moodul . Indiviidiks määratakse automaatselt nimisõnad , asesõnad , pärisnimed , määrsõnad . Predikaadi otsimise moodul . Predikaadi variandid : Omadussõna Tegusõna Ülivõrre Ole vormid + omadussõna Ole + ülivõrre Ole + tegusõna või mitu , näiteks kaks tegusõna ühe predikaadi rollina Ole + nimisõna nimetavas käändes Predikaadi moodustamine . Predikaatide jaoks , mis koosnevad mitmest sõnast , on kirjutatud lisamoodul , mis ühendab sõnad üheks osaks ja uuendab vajalikud failid . Sõnade järjekord lauses ei ole oluline . Predikaate moodustatakse morfoloogilise skeemi järgi . Kvantori defineerimise moodul . Variantides “ Iga x on P ( x ) ” on x-rollis sõna , mis paikneb pärast kvantori rollis olevat sõna . Variantides “ Leidub x , mis on P ( x ) ” on x-rollis nimisõna nimetavas käändes . Aja sümbolite tuvastamise moodul . Otsitakse tegusõnu erinevates ajavormides ja tähistatakse vastava indeksiga . Tulemusi pakutakse kasutajale kinnitamiseks . Kasutaja mittenõustumise puhul aja järjestusega ei arvestata . Sõnade võrdlemine . Moodul , mis tuvastab ühe sõna erinevad vormid ( näiteks mina , minule , minult ) . Leitud sõnad väljastatakse ekraanile kasutajale kinnitamiseks . Valemi korrigeerimine . Moodul , mis lubab sõnade väljajätmist ja loogilise rolli vahetamist . Valemi kontroll . Moodul , mis kontrollib üle lauseosade esituse preformaalsust . Hoiatuse väljastamine . Loogilise konstruktsiooni moodustamise moodul . Indiviidi tähiseks on qi, predikaadi tähiseks on Pi. Juhul kui lauses olid kasutusel ühe sõna erinevad vormid , pakutakse tähisteks vastavalt xija Ai.  Joonis <arv>. Valemi moodustamine transform.pl Olemasolevate skeemide uurimine . Avastatud skeeme väljastatakse valikutegemiseks . Kui sobivat skeemi ei ole leitud , pakutakse kasutajale programmi õpetamist . Script õpetamine on kaitstud parooliga , et vältida süsteemi ebaprofessionaalset väljaõpetamist . Kui kasutaja on leidnud , et automaatne transformatsioon ei ole sobiv , siis selles scriptis on võimalik minna samm-sammult õpetamise juurde . study.pl Selle scripti käivitamine näitab , et andmebaasis ei ole leitud vastavat morfoloogilist skeemi . Script on mõeldud programmi õpetamiseks samm-sammult . Kasutaja täidab tekstikasti järgmise lause vormiga ja seejärel läbitakse samas aknas morfoloogiline analüüs , mis sisuliselt vastab scriptile e<arv>.pl. See script võimaldab kõigepealt käsitsi sisestada lause järgmise transformeerimise sammu ( valik <arv> ) . Järgmisele sammule saatmiseks on nupp “ Edasi ” , mis käivitab sama scripti . Pärast scripti tagasisuunamist kirjutatakse uus muutuja sõnadega faili ja viiakse läbi morfoloogiline analüüs ( valik <arv> ) . Kui analüüs on läbitud , on võimalik minna järgmisele scriptile ( v<arv>.pl ) . v<arv>.pl  Joonis <arv>. Lause transformeerimine Script on mõeldud transformatsiooni kokkuvõtete tegemiseks . Kasutusel on järgmised moodulid : moodul vajalike andmete sisselugemise ja korrastamise analüüsiks , moodul , mis saab aru , kuidas on muutunud sõnade järjekord . autotransform.pl Script käivitatakse siis , kui on leitud transformeerimise skeem . Scripti eesmärk on lihtsustada lausete transformeerimist , pakkudes kasutajale võimalikud lausekujud , mis peavad olema sobivad loogilise konstruktsiooni moodustamisel . Scripti realiseerimiseks on võetud kasutusele päringud keele süntesaatorisse , kus on võimalik sõna algvormile valida vastav morfoloogiline tähis ja mis väljastab selle sõna õiges vormis . Programmis on järgmised moodulid : andmete ettevalmistus analüüsiks , andmete ettevalmistus päringuks “ Keele süntesaatorisse ” ja tulemuse saamine , kasutajapoolne lausete ja sõnade kinnitamine . Andmete ettevalmistamine valemi koostamiseks , mis toimub scriptis e<arv>.pl.  Joonis <arv>. Automaatne transformeerimine <arv>.pl Script on mõeldud andmebaasi täiendamiseks . Väljastatakse lause ja antakse võimalus sisestada selle lause esitanud lapse sünnipäev ning uuringute kuupäev . Andmebaasi valikud võivad olla järgmised : isiklik , uuringud . Kui transformeerimine ei olnud mõeldud uuringuteks , ei pea valima lapse sünnipäevaandmeid . Olemasolevaid transformeeritud lauseid saab lisada andmebaasi korraldusega “ Salvesta ” . Kui kasutaja ei soovi andmebaasi täiendada , on võimalik minna esilehele või varem sisestatud lausete valiku juurde . Lausete valik töötlemiseks . Scriptis on antud selliste lausete loetelu , mis olid sisestatud scriptis index.pl . Lausete ette on lisatud “ raadionupud ” , mille abil kasutaja saab teha oma valiku . Graafilises keskkonnas suunatakse programm nupuga “ Edasi ” algusesse ( index.pl ) . Kui soovitakse mõningaid lauseid kustutada , siis on vaja lause välja valida ja vajutada nuppu “ Kustuta ” . <arv>. PROGRAMMI ALGORITMI KOOSTAMISEGA SEOTUD ETAPID JA PROBLEEMID Programmi koostamine algas sellest , et oli vaja leida võimalusi sõnaliikide tuvastamiseks , näiteks olemasolevaid andmebaase , millesse saaks teha päringuid . Pärast uuringuid ja otsinguid võeti kasutusele firma FILOSOFT poolt koostatud morfanalüsaator , mis võimaldas kätte saada vajalikud morfoloogilised tähised . Dialoogsüsteemis oli vaja asendada need tähised vastavate tähendustega . Kasutajapoolse kinnitamise tulemusena moodustus uus hulk andmeid , millega oli võimalik opereerida sõnade rollide määramisel . Predikaatide rollide määramiseks oli aga vaja töötada läbi palju tekste , et selgitada välja , mis sõnaliigid täpsemalt saavad olla vastavas rollis , lisaks oli üsna tihti nimetatud rollis korraga mitu sõna . Kombinatsiooni “ on + nimisõna nimetavas käändes ” korral pidi vaatama ka seda , kas lauses on säärases vormis nimisõna esinenud esimest korda või mitte . Sest lauses “ Kassike on naljakas ” ei ole nimisõna “ kassike ” predikaadi osa , aga lauses “ Mina olen kassike ” predikaadiks on sõnade kombinatsioon “ olen kassike ” . Sümbolite positsioneerime osutus valemi koostamisel üsna keeruliseks ülesandeks . Loomuliku keele tekstides ei asetse sõnad sageli vajalikes positsioonides . Oli vaja kindlaks teha , mis variandid võivad tekkida valemi koostamisel ja uurida sümbolite positsioneerimisi . Et vältida probleeme , mis on seotud alaindeksite kasutamisega HTML-keele tekstiväljadel indiviidide ja predikaatide indekseerimiseks , võeti kasutusele tavalised ( mitte alaindeksikujulised ) numbrid ja tulenevalt programmeerimise mugavusest loobuti komade kasutamisest indiviidide eraldamisel . Eituse , olemasolukvantori ja ülduskvantori puhul selgus , et valemi pilt varieerub vastavalt sõnade järjekorrale . Näited . “ Täna ei ole ilus ilm ” annab valemi P<arv> ( q<arv> q<arv> ) “ Iga inimene ei ole õnnelik ” ( " q<arv> ) P<arv> ( q<arv> ) “ Ei ole ilus vaielda iga inimesega ” ( " q<arv> ) P<arv> ( q<arv> ) Siin ei ole vaja anda lausele teist kuju , näiteks : “ Ei ole õige , et iga inimese puhul on ilus vaielda selle inimesega ” . “ Igal õhtul leidub ebameeldivaid inimesi ” ( " q<arv> ) ( $q<arv> ) P<arv> ( q<arv> q<arv> ) “ Leidub inimene , kes igal õhtul hilineb ” ( $q<arv> ) ( " q<arv> ) P<arv> ( q<arv> q<arv> ) Valemi moodustamine ei vaja ümbersõnastamist , kui lause kuju sisaldab valemi koostamiseks vajalikke elemente ( sõnu ) . Programmi osas , mis otsib ühe sõna erinevaid vorme ning mille eesmärk on indekseerida indiviide ja predikaate vastavate ( korduvate ) indeksitega , osutus probleemiks see , et predikaat ei pruugi koosneda ainult ühest sõnast . Oli vaja võrrelda mitte lihtsalt sõnade algvorme , vaid loogiliste osade algvorme . Näide . Kui kõik inimesed on ilusad ja mina olen inimene , siis mina olen ilus . ( " x<arv> ) P<arv> ( x<arv> ) &amp; P<arv> ( x<arv> x<arv> ) É P<arv> ( x<arv> ) Nn titekirjanduse tekstide transformeerimisel hakkasid esile tulema kordused vastavalt lause morfoloogilisele skeemile . Tänu sellele , et on välja töötatud eesti keele süntesaator , osutus võimalikuks terve lause sõnade genereerimine vajalikes vormides salvestatud “ stsenaariumi ” järgi . Automaatse transformeerimise puhul väljastati algvariandis kõik vahesammud . See aga viis üleliigsete valikute kinnitamiseni . Üldised tulemused aga ei sõltu vahesammudes tehtud valikutest . Võimalike vigade tekkimisel saab kasutaja sõnalõppe kohandada vastavalt lause tähendusele . <arv>. KOKKUVÕTE Loogilise mõtlemise vahendite mõistmine ja rakendamine on muutunud kaasaegses maailmas üha olulisemaks . Inimese loogilisele mõtlemisele iseloomulike vahendite rakendamine on osutunud vajalikuks nii uute tehniliste vahendite väljatöötamisel , tehisintellekti süsteemide loomisel , aga nii paradoksaalne , kui see ka ei tundu , inimese enda arendamisel . Koolides läbiviidud uuringud kinnitavad , et loogikaga on üldiselt “ kehvad lood ” , kusjuures ilmneb , et n-ö loogiline võimekus kohati langeb klassist klassi ( algastmest lõppu ) liikudes . See tekitab küsimusi , kas pole viga viimati selles , et lastele lähenetakse niisuguse loogikaga , mis antud vanuses pole kohane . Kusjuures see , millised on antud vanuserühmale ( või loomulikule arengutasemele ) iseloomulikud loogilised vahendid , pole sugugi selge . Nimetatud loogiliste vahendite uurimiseks tuleb need kõigepealt “ kätte saada ” ja siin on üheks võimalikuks viisiks eespool kirjeldatud dialoogsüsteemi rakendamine . TSITEERITUD ALLIKAD ( Baranov D. ) Áàðàíîâ Ä. <arv>. Äèàëîãîâàÿ ñèñòåìà äëÿ ëîãè÷åñêîé îáðàáîòêè òåêñòîâ åñòåñòâåííîãî ÿçûêà . Lõputöö . Tallinn : TTÜ . Lorents D. <arv>. Loogilised konstruktsioonid eesti keele tekstides . Valemite tase . Lõputöö . Tallinn : TPÜ . Lorents P. <arv>. Keel ja loogika . Tallinn : EBS-PRINT . Lorents P. , Motus L. , Tekko J. <arv>. A language and calculus for distributed computer control systems description and analysis . <arv>th IFAC/IFIP Symposium on Software for Computer Control , Graz , Austria May <arv>-<arv>. ( Lorents P. , Mõtus L. ) Ëîðåíòñ Ï . Ï . , Ìûòóñ Ë . Ë . <arv>. Ëîãè÷åñêèå ñðåäñòâà îïèñàíèÿ è àíàëèçà ñèñòåì âçàèìîäåéñòâóþùèõ ïðîöåññîâ ñ íàëîæåííûìè âðåìåííûìè îãðàíè÷åíèÿìè . IV Âåñîþçíàÿ êîíôåðåíöèÿ “ Ïðèìåíåíèå ìåòîäîâ ìàòåìàòè÷åñêîé ëîãèêè ” . Òåçèñû äîêëàäîâ . Èíñòèòóò Êèáåðíåòèêè ÀÍ ÝÑÑÐ . Òàëëèíí . ( Maltsev A. I. ) Ìàëüöåâ À . È . <arv>. Àëãîðèòìû è ðåêóðñèíûå ôóíêöèè . Ìîñêâà : Hayka . Rogers H. <arv>. Theory of Recursive Functions and Effective Computability . New York . St Louis . San Francisco . Toronto . London . Sydney : McGraw-Hill Book Company . ( Venekeelne tõlge ilmus kirjastuse “ Ìèð ” väljaandena aastal <arv> ) . ( Uspenski V.A. , Semjonov A. L. ) Uudiseid kogus , Uuno Vallner , Majandus- ja Kommunikatsiooniministeeriumi IT arhitektuuri talituse juhataja KOALITSIOONILEPING JA E-RIIK Valitsuse koalitsioonilepingu punktid <arv>-<arv> käsitlevad IT probleeme riigis : <arv>. Valitsusliit arendab avaliku halduse toimimisviise eesmärgiga muuta infotehnoloogiliste vahendite abiga teenindus inimestele mugavamaks . <arv>. Valitsusliit toetab riigi ITarendusprojektide keskselt koordineeritud ja projektipõhist rahastamist . <arv>. Kõik riigi teenused peavad olema kättesaadavad kõigis maakonnakeskustes . Selleks kohustab valitsusliit riigiasutusi maakonnakeskustes sisse seadma vastuvõtuajad , et inimesed saaksid põhilised teenused kätte , või muutma asjaajamised ( toimingud ) võimalikult lihtsaks ja elukohalähedaseks . EUROOPA ERGUTAB INTERNETI PAKKUMIST ELEKTRIKAABLITE KAUDU Euroopa Komisjon võttis vastu otsuse , et konkurentsi ergutamiseks ning USA-le ja Jaapanile järelejõudmiseks peaksid energiafirmad hakkama oma elektrikaablite kaudu ka Internetti pakkuma . Praegu saavad pistikupesast kiiret Internetti umbes <arv> Itaalias , Hispaanias ja Prantsusmaal elavat eurooplast . EESTI LAIRIBASTRATEEGIA <arv>-<arv> Vabariigi Valitsus kiitis heaks “ Eesti lairibastrateegia aastateks <arv>-<arv> ” , mille koostamise vajadus tulenes Euroopa Liidu e-Euroopa tegevuskavast ja milles nähakse kiire Internetiühenduse levikut infoühiskonna ülesehitamise eeldusena . Strateegia üldine eesmärk on teha kõigile elanikele kättesaadavaks era- ja avaliku sektori poolt pakutavad digitaalsed teenused ning aidata seeläbi kaasa Eesti konkurentsivõime kasvule , uute töökohtade loomisele ning ühiskonna kommunikatsiooni- ja transpordikulutuste vähendamisele . Eesmärgi hindamise kvantitatiivseks näitajaks on Eesti jõudmine püsiühenduste suhtarvult EL-i kolme juhtiva riigi hulka . Strateegia on heaks kiitnud Eesti Informaatikanõukogu oma <arv>. novembri <arv>. a istungil . ITL ANDIS AASTAAUHINDU Eesti Infotehnoloogia- ja Telekommunikatsiooniettevõtjate Liit andis teabemessi “ Kontakt <arv> ” raames välja traditsioonilised aastaauhinnad . Aasta tegijaks nimetati Peeter Marvet , tiitli ” Aasta tegu ” pälvis AS Sertifitseerimiskeskuses välja töötatud ID-pilet ning aasta haridusauhinna sai projekt Eesti e-ülikool . Peeter Marvet pälvis selle tiitli infotehnoloogia sõnumi laiadesse rahvamassidesse kandmise eest . ID-pilet aga on piletisüsteemide maailmas unikaalne pretsedent ja uudne lähenemine pileti mõistele , mille suunas arenenud tehnoloogiariikides alles liigutakse . AMPHORA LOODAB JÕUDA VÄLISTURGUDELE Esialgu mitmesuguseid veebiportaali teenuseid pakkunud ettevõte Interinx profileeris end hiljuti tarkvaraarendajaks ning planeerib nüüd oma uue dokumendihaldustarkvaraga Amphora <arv> minna Läti , Leedu ja Rootsi tarkvaraturgudele . Tarkvara aitab jagu saada mitmes ametkonnas võidutsevast liigsest bürokraatiast . Uus versioon kannab ametlikku nime Ampfora <arv> Professional . Interinxi arvates on Eestis mõneti segamini aetud kaks asja - asjaajamine ja dokumendihaldus . Asjaajamine toetab äritegevust ning peaks kuuluma infoteaduste valdkonda . Ekslikult nimetatakse meil selleks aga dokumendihaldust , mis on tegelikult dokumentide haldamine ja arhiveerimine , millel pole midagi tegemist probleemide lahendamisega . Amphora on midagi universaalsemat kui lihtsalt dokumendihaldustarkvara -see on pigem asjaajamistarkvara , mis lahendab lõpptulemusena ka probleeme . WORLD SUMMIT AWARD EESTI EELVOORU VÕITJAD <arv>. aprillil <arv> selgusid ülemaailmse e-valdkonna projektide konkursi World Summit Award ( WSA ) Eesti eelvooru võitjad . World Summit Award ( WSA ) on võistlus , mille käigus selgitatakse välja ja tutvustatakse maailma parimaid e-valdkonna projekte . Konkursi eesmärk on kultuuriliste erinevuste ja identiteedi tunnustamine , mitmesuguste sisuteenuste loomine ning hariduse , teaduse ja kultuuripärandi digitaliseerimine . <arv>. a võistlusel osaleb <arv> riiki kogu maailmast , esindatud on kõik kontinendid . Võistlus toimub kaheksas kategoorias : e-õpe , e-kultuur , e-teadus , e-valitsus , e-tervis , e-äri , e-meelelahutus , e-kaasatus . Igast kategooriast saab osalev riik saata end esindama ühe projekti . World Summit Award <arv> Eesti eelvooru võiduprojektid kategooriate kaupa : Kategooria : e-õpe : Virtuaalne aabits “ Virbits ” .Tootja : Eesti Kunstiakadeemia Kategooria : e-valitsus : E-hääletamise süsteem . Tootja : Vabariigi Valimiskomisjon Kategooria : e-tervis : Online arsti vastuvõtu süsteem . Tootja : Tervisepank OÜ Kategooria : e-äri : Igaühe m-äri . Tootja : Mobi Solutions OÜ Kategooriates e-teadus , e-meelelahutus , e-kultuur ja e-kaasatus projekte ei esitatud . Kategooriate ülemaailmsed võitjad kuulutatakse välja novembris <arv> Tuneesias . Eestile on WSA ajalugu edukas : <arv>. aastal esmakordselt toimunud võistluse üks võitjatest oli firma Docobo Ltd projektiga doc@home . WSA projekti algatajaks on European Academy of Digital Media . Võistluse peakorraldaja on International Center for New Media , võistlust toetavad ÜRO , UNICEF , Euroopa Komisjon jt. Tänavune konkurss viiakse läbi ÜRO infoühiskonnaalase tippkohtumise raames novembrikuus Tuneesias . Eesti eelvooru korraldajaks on Disaini Innovatsioonikeskus . SAARE MAAKONNA ÜHTNE DOKUMENDIHALDUSE PROJEKT Saare maavalitsuse kõik maakonna omavalitsused , välja arvatud Ruhnu , käsutavad praegu firma IBM tarkvara Lotus Notes . Esialgsel kujul on omavalitsuste ühine veebileht üleval aadressil <hyperlink> , kus kõigil huvilistel on võimalik ülesriputatud dokumente vaadata . Maakondliku infotehnoloogiaprojekti raames hangiti kõikidele omavalitsustele kaks kuni viis , linnale aga paarkümmend tarkvaralitsentsi . Vastavalt eraldatud litsentside arvule said kõik omavalitsused projekti raames saata oma töötajaid ka tarkvara kasutajakoolitusele . Samuti korraldati koolitus kõikidele vallasekretäridele , kes peavad jooksvalt õigusakte veebikeskkonda sisestama . INTERNETTI KASUTAB <arv> PROTSENTI EESTIMAALASTEST . TNS Emori uuringu põhjal kasutab Internetti <arv> <arv> inimest , mis moodustab <arv> protsenti <arv>-<arv>-aastastest eestimaalastest . Võrreldes eelmise aastaga , on Interneti kasutajaskond suurenenud <arv> <arv> inimese võrra . Internetiühenduse laialdane levik kodudes on tõstnud ka interneti kasutamise aktiivsust - <arv> protsenti internetikasutajatest veedab aega internetis iga päev . Aasta tagasi oli igapäevakasutajaid <arv> protsenti . Viimase aasta jooksul on Internetikasutajate seas suurenenud naiste osakaal , samuti on kasutajaskonda lisandunud rohkelt inimesi vanuses <arv>-<arv> aastat , keskharidusega inimesi ning väiksemate linnade ja maa-asulate elanikke . Andmete aluseks on TNS Emori e-seire uuring , mis kaardistab arvuti ja interneti valdkondade arengut . E-seire uuringut viiakse läbi regulaarselt kord kuus , mil küsitletakse <arv> eestimaalast vanuses <arv>-<arv> aastat . MESSIL CeBITOLI KA EESTI STEND Saksamaal Hannoveris nädal aega kestev mess CeBIT on kohtumispaigaks paljudele Eesti IT-inimestele . Messil osalemine ei ole odav lõbu - sel aastal on messil terve Eesti peale üleval ainult üks stend , mida kulude kokkuhoiu pärast jagab riik eraettevõtjatega . Riik kulutas messil osalemiseks ja seal Eesti kui edumeelse m-riigi tutvustamiseks <arv> <arv> krooni . Messil osalemiseks kulutatud raha kasutegurit on keeruline hinnata . Seda kinnitavad nii meie ettevõtjad kui ka muude riikide messil osalevad firmad . Suhete loomiseks on CeBIT ideaalne koht - siin on kohal üle <arv> firma <arv> riigist . Arvo Toomsalu , TTÜ arvutitehnika instituut Käesoleva aasta <arv>.-<arv>. veebruarini toimus San Franciscos Elektri- ja Elektroonikainseneride Instituudi ( IEEE ) rahvusvaheline konverents ISSCC<arv>teemal “ Entering the Nanoelectronic Integrated-Circuit Era ” . Konverentsil tutvustas firma Seiko Epson Corp . oma uusimat <arv>bitise sõnapikkusega mikroprotsessorlülitust ACTII . Vaevalt et see sündmus oleks pälvinud suuremat rahvusvahelist tähelepanu , kui tegu poleks olnud maailma esimese elastse mikroprotsessorlülitusega : nimelt ei asu mikrolülitus ACTII mitte tavapärases jäigas korpuses , vaid elastsel plastalusel . Vastvalminud mikroprotsessorlülituse omapära ei piirdu ainuüksi selle tehnoloogilise uuendusega . Tegemist on ka äärmiselt energiasäästliku mikroprotsessoriga . Mikrolülituse energiatarbe minimeerimiseks loobuti protsessori talitluse korraldamisel sünkroonsest mudelist ja mindi üle asünkroonsele . Võrreldes analoogiliste sünkroonsete konkurentidega , on Epsoni uue mikroprotsessori energiatarve kuni <arv>% väiksem . Mikroprotsessorlülitust ACTII iseloomustab hästi märksõna “ säästlikkus ” . Säästlikkus avaldub nii protsessori sisemiste ressursside efektiivses rakendamises , ülimadalas energiatarbes kui ka lülituse tagasihoidlikes mõõdetes . LTPS-TFT-kiletehnoloogias ( L ow- T emperature P oly S ilicon T hin- F ilm T ransistor ) valmistatud plastalusel protsessorlülituse jälgpind on <arv>,<arv> x <arv>,<arv> mm , paksus <arv> ìm ja kaal kõigest <arv> milligrammi . <arv> <arv> transistorit sisaldava protsessori arhitektuurne lahendus sarnaneb Epsoni <arv>bitise mikroprotsessorsarja S<arv>C<arv> lülituste omaga . Elastse mikroprotsessorlülituse väljatöötamisel ühendati edukalt LTPS-TFT-tehnoloogia juba varem firmas välja töötatud SUFTLA-tehnoloogiaga ( S urface F ree T echnology by L aser A blation/ A nnealing ) . Nende kahe tehnoloogia sümbioos võimaldab luua mitmesuguseid keerukaid , väga erinevatesse rakendustesse sobivaid madala energiatarbega loogikalülitusi . Mikroprotsessorkiibi ACTII toitepinge on muudetav vahemikus <arv>,<arv> V kuni <arv> V. Maksimaalsel taktsagedusel <arv> kHz ja toitepingel <arv> V ei ületa protsessorkiibi voolutarve <arv> mikroamprit . Nähes esmakordselt mikroprotsessori ACTII näitajaid , meenus üks teine , juba aastakümneid tagasi valminud , mikroprotsessorlülitus . Nimelt leidis mikroprotsessortehnika arengu seisukohalt väga oluline sündmus aset aastal <arv> , kui firma Intel Corp tõi turule oma esimese <arv>bitise mikroprotsessorkiibi <arv> . Just tänu sellele ja aasta hiljem valminud mikroprotsessorile <arv> sai massiline personaalarvutite tootmine hoo sisse . Kõnekas on fakt , et sünkroonse <arv>bitise mikroprotsessorlülituse <arv> transistoride arv oli väiksem , kui seda on Epsoni praeguses asünkroonses <arv>bitises mikroprotsessoris . <arv>mikronilises CMOS-tehnoloogias valmistatud <arv>s sisaldus vaid <arv> <arv> transistorit . Hoolimata väiksemast transistoride arvust , küündis Inteli mikrolülituse energiatarve <arv>voldise toitepinge ja <arv>megahertsilise taktsageduse juures kuni <arv>,<arv> vatini . Seega ületas Inteli mikroprotsessori voolutarve ACTII oma enam kui <arv> korda ! Tuleb järjekordselt tõdeda , et tehnoloogia areng möödunud aastate jooksul on olnud muljet avaldav . Uute mikroprotsessorite põhilist kasutusvaldkonda näeb firma eeskätt erinevates mobiilsetes süsteemides . Vahest lisavad elastsed mikroprotsessorlülitused hoogu ka arvutitehnika seni suhteliselt tagasihoidlikult arenenud ja vähem tuntud valdkonna wearable computing arengule . Kuna seni on firma veel üsna napilt jaganud teavet oma uue toote kohta , siis soovitaks protsessorlülitusest sügavamalt huvitatuil hoida silm peal Epsoni veebilehel aadressiga <hyperlink> <arv> ISSCC - International Solid-State Circuits Conference . Konverentsi programmiga saab tutvuda võrguaadressil : <hyperlink>